import{r as m,j as e,D as j}from"./index-CmLoEHr4.js";import{D as i,E as r,T as o}from"./Boxes-C2JDTLZ9.js";import{N as d,T as s,W as c}from"./StickyNotes-CLWbDoEg.js";import{p as u,N as v,r as f}from"./NoteDocument-CPcpW-c5.js";import{L as a,r as n}from"./LaTeX-7gQEXWJ1.js";const g=u.div`
  width: 100%;
  margin-bottom: 1em;
  display: block;
`,_=u.h2`
  font-size: 1.5em;
  color: white;
  background-color: var(--section-color);
  padding: 0.2em 0;
  width: 100%;
  text-align: center;
  
  border-radius: 0 10px 10px 10px;
  cursor: pointer;
`,y=u.div`
  display: ${t=>t.$expanded?"block":"none"};
  width: 100%;
  padding: 0;
  margin: 0;
`,l=({title:t,children:h})=>{const[x,b]=m.useState(!0),p=()=>{b(!x)};return e.jsxs(g,{children:[e.jsx(_,{$expanded:x,onClick:p,children:t}),e.jsx(y,{$expanded:x,children:h})]})},k=()=>e.jsxs(v,{children:[e.jsx("h1",{children:"Cálculo Vectorial"}),"El cálculo vectorial es una rama de las matemáticas que estudia el cálculo en funciones con valores vectoriales. En particular, se enfoca en funciones escalares y vectoriales de múltiples variables. En este documento se estudian las funciones con valores reales, los límites de múltiples variables, las derivadas parciales, las derivadas direccionales, los diferenciales, los gradientes, las integrales múltiples y los teoremas de la divergencia y de Stokes.",e.jsxs(l,{title:"Funciones con valores reales",children:[e.jsx("p",{children:"Una función es una regla que asigna un elemento a otro específico, mas nunca asigna al mismo elemento dos distintos."}),e.jsxs("p",{children:["En las funciones con valores reales, dichos elementos pueden ser tanto escalares ",e.jsx(a,{children:n`x \in \mathbb{R}`})," como vectores ",e.jsx(a,{children:n`\bvec{x}\in\mathbb{R}^{n}`}),", con ",e.jsx(a,{children:n`n \in \mathbb{N} \setminus \{0, 1\}`}),". Ergo, toda ",e.jsx("em",{children:"función con valores reales"})," tiene la forma ",e.jsx(a,{children:n`f\colon A\subseteq\mathbb{R}^{m}\to\mathbb{R}^{n}`}),". A cada elemento del conjunto ",e.jsx(a,{children:n`A=\dom f`}),", que puede ser un vector o escalar dependiendo del valor de ",e.jsx(a,{children:n`m \in \mathbb{N} \setminus \{0\}`}),", le corresponde un único elemento ",e.jsx(a,{children:n`f(\bvec{x}) \in \ran f \subseteq \mathbb{R}^{n}`}),", vector o escalar dependiendo de ",e.jsx(a,{children:n`n \in \mathbb{N} \setminus \{0\}`}),". Las funciones con valores reales se clasifican de acuerdo a qué son sus elementos."]}),e.jsxs(i,{concept:"Función escalar",children:["Una ",e.jsx("em",{children:"función escalar"})," ",e.jsx(a,{children:n`f`})," es una función de forma ",e.jsx(a,{children:n`f\colon A\subseteq\mathbb{R}^{m} \to \mathbb{R}`})," donde ",e.jsx(a,{children:n`m \in \mathbb{N} \setminus \{0\}`}),", tal que los elementos en su rango son escalares."]}),e.jsxs(i,{concept:"Función vectorial",children:["Una ",e.jsx("em",{children:"función vectorial"})," ",e.jsx(a,{children:n`\bvec{F}`})," es una función de de forma ",e.jsx(a,{children:n`\bvec{F}\colon A\subseteq\mathbb{R}^{m} \to \mathbb{R}^{n}`})," donde ",e.jsx(a,{children:n`m \in \mathbb{N} \setminus \{0\}`})," y ",e.jsx(a,{children:n`n \in \mathbb{N} \setminus \{0,1\}`}),", tal que los elementos en su rango son vectores."]}),e.jsxs("p",{children:["Una función vectorial de forma ",e.jsx(a,{children:n`\bvec{F}\colon A \subseteq \mathbb{R}^{m}\to \mathbb{R}^{n}`}),", recibe un escalar o un vector elemento de ",e.jsx(a,{children:n`\mathbb{R}^{m}`})," y tiene como imagen un vector ",e.jsx(a,{children:n`\bvec{F}(\bvec{x}) \in \mathbb{R}^{n}`}),". Por eso, se puede expresar una función vectorial como un vector con ",e.jsx(a,{children:n`n`})," funciones escalares,",e.jsx(a,{block:!0,children:n`\bvec{F}=(F_1,F_2,\ldots,F_n).`})]}),e.jsxs(d,{children:["Las funciones escalares se denotan por letras minúsculas, usualmente las letras ",e.jsx(a,{children:n`f`}),", ",e.jsx(a,{children:n`g`})," y ",e.jsx(a,{children:n`h`}),". Las funciones vectoriales se denotan por letras mayúsculas en negrilla,  usualmente las letras ",e.jsx(a,{children:n`\bvec{F}`}),", ",e.jsx(a,{children:n`\bvec{G}`})," y ",e.jsx(a,{children:n`\bvec{H}`}),"."]}),e.jsxs(i,{concept:"Función de una variable",children:["Una ",e.jsx("em",{children:"función de una variable"})," ",e.jsx(a,{children:n`f`})," es una función de forma ",e.jsx(a,{children:n`f\colon A\subseteq\mathbb{R}\to \mathbb{R}^{n}`}),", tal que los elementos en su dominio son escalares."]}),e.jsxs(i,{concept:"Función de múltiples variables",children:["Una ",e.jsx("em",{children:"función de múltiples variables"})," ",e.jsx(a,{children:n`f`})," es una función de forma ",e.jsx(a,{children:n`f\colon A\subseteq\mathbb{R}^{m}\to \mathbb{R}^{n}`})," donde ",e.jsx(a,{children:n`m>1`}),", tal que los elementos en su dominio son vectores."]}),e.jsx("p",{children:"Una función de una variable puede ser escalar o vectorial. Lo mismo sucede para una función de múltiples variables. En las definiciones se denotan como si fueran funciones escalares, pero bien podrían haberse denotado como funciones vectoriales. Así pues, existen funciones escalares de una o varias variables y funciones vectoriales de una o varias variables. Probablemente, las funciones que ha estudiado hasta el momento son funciones escalares de una variable."}),e.jsxs(i,{concept:"Campo vectorial",children:["Un campo vectorial ",e.jsx(a,{children:n`\bvec{F}`})," es una función vectorial de múltiples variables."]}),e.jsxs("p",{children:["De acuerdo con la definición anterior, un campo vectorial tiene la forma ",e.jsx(a,{children:n`\bvec{F}\colon A\subseteq\mathbb{R}^{m} \to \mathbb{R}^{n}`})," donde ",e.jsx(a,{children:n`m,n \in \mathbb{N} \setminus \{0,1\}`}),", tal que los elementos en su dominio y rango son vectores: recibe un vector ",e.jsx(a,{children:n`\bvec{x}\in \mathbb{R}^{m}`})," y tiene como imagen un vector ",e.jsx(a,{children:n`\bvec{F}(\bvec{x}) \in \mathbb{R}^{n}`}),". Como es una función vectorial, se puede expresar de forma",e.jsx(a,{block:!0,children:n`
	\bvec{F}=(F_1,F_2,\ldots,F_n)
`}),"y se evalúa de la siguiente manera:",e.jsx(a,{block:!0,children:n`\begin{gather*}
	\bvec{F}(\bvec{x})=(F_1(\bvec{x}),F_2(\bvec{x}),\ldots,F_n(\bvec{x}))\\
	\bvec{F}(x_1,x_2,\ldots,x_m)=(F_1(x_1,x_2,\ldots,x_m),F_2(x_1,x_2,\ldots,x_m),\ldots,F_n(x_1,x_2,\ldots,x_m)).
\end{gather*}`})]}),e.jsxs(r,{title:"Ejemplos de funciones escalares y vectoriales",children:["Un ejemplo de una función escalar de una variable, ",e.jsx(a,{children:n`f\colon\mathbb{R}\to\mathbb{R}`}),":",e.jsx(a,{block:!0,children:n`\begin{gather*}
		f(x)=x^2+\log_3(x)
	\end{gather*}`}),"Un ejemplo de una función escalar de múltiples variables, ",e.jsx(a,{children:n`g\colon\mathbb{R}^{5}\to\mathbb{R}`}),":",e.jsx(a,{block:!0,children:n`
		g\colon\begin{pmatrix}
				x_1\\x_2\\x_3\\x_4\\x_5
			\end{pmatrix}\mapsto\cos(x_1+x_3)+\sin(x_2+x_4)+\mathrm{e}^{x_5}.
	`}),"Un ejemplo de una función vectorial de una variable, ",e.jsx(a,{children:n`\bvec{F}\colon\mathbb{R}\to\mathbb{R}^4`}),":",e.jsx(a,{block:!0,children:n`
					\bvec{F}(x) = \begin{pmatrix}
						x^{x} \\ (1+x) / x^5 \\ \tanh x \\ x
					\end{pmatrix}.
				`}),"Un ejemplo de un campo vectorial, ",e.jsx(a,{children:n`\bvec{G}\colon\mathbb{R}^{3}\to\mathbb{R}^6`}),":",e.jsx(a,{block:!0,children:n`
			\bvec{G}\colon\begin{pmatrix}
			x\\y\\z
			\end{pmatrix}\mapsto\begin{pmatrix}
			\ln(x+y) \\ x^2 \\ \tan(x-y) \\y^2 \\ x^2+y^2 \\ \arccsc(y)
			\end{pmatrix}.
    `})]}),e.jsx("h3",{children:"Gráfica de una función escalar"}),e.jsxs("p",{children:["Las funciones escalares más simples son las de una variable, de forma ",e.jsx(a,{children:n`f\colon A\subseteq \mathbb{R}\to\mathbb{R}`}),". La gráfica de dichas funciones es el conjunto de los puntos ",e.jsx(a,{children:n`(x,f(x))`}),", dispuestos en el plano para todo ",e.jsx(a,{children:n`x`})," en ",e.jsx(a,{children:n`\dom f = A`}),". Esa curva es el siguiente subconjunto de ",e.jsx(a,{children:n`\mathbb{R}^{2}`}),":",e.jsx(a,{block:!0,children:n`\text{gráfica } f = \set{(x,f(x)) \in\mathbb{R}^{2}\mid x\in A}`})]}),e.jsxs("p",{children:["Generalizando lo anterior, para cualquier función escalar ",e.jsx(a,{children:n`f\colon A\subseteq \mathbb{R}^n\to\mathbb{R}`}),", su gráfica será un subconjunto de ",e.jsx(a,{children:n`\mathbb{R}^{n+1}`}),". Las gráficas de funciones escalares de una variable se denominan ",e.jsx("em",{children:"curvas"})," y las gráficas de funciones escalares de dos variables se denominan ",e.jsx("em",{children:"superficies"}),"."]}),e.jsxs(i,{concept:"Gráfica de una función escalar",children:["Dada una función escalar ",e.jsx(a,{children:n`f\colon A\subseteq\mathbb{R}^{n}\to\mathbb{R}`}),", su ",e.jsx("em",{children:"gráfica"})," es el conjunto de los puntos ",e.jsx(a,{children:n`(x_1,x_2,\ldots,x_n,f(x_1,x_2,\ldots,x_n))`})," para todo ",e.jsx(a,{children:n`\bvec{x}\in A`}),". Definido por compresión:",e.jsx(a,{block:!0,children:n`\text{gráfica } f = \set{(x_1,x_2,\ldots,x_n,f(x_1,x_2,\ldots,x_n)) \in \mathbb{R}^{n+1} \mid (x_1,x_2,\ldots,x_n) \in A}`})]}),e.jsxs(s,{children:["La gráfica de una función no es más que un vector que contiene a todas las variables y a la imagen de la función. Recuérdese que ",e.jsx(a,{children:n` f(x_1,x_2,\ldots,x_n) = f(\bvec{x})`})," es un número, que es distinto para cada vector ",e.jsx(a,{children:n`\bvec{x}\in A`})," de variables."]}),e.jsxs("p",{children:["El comportamiento de funciones escalares ",e.jsx(a,{children:n`f\colon A\subseteq \mathbb{R}^n\to\mathbb{R}`})," se puede entender mediante ",e.jsx("em",{children:"conjuntos de nivel"}),". Un conjunto de nivel es un subconjunto de ",e.jsx(a,{children:n`\mathbb{R}^{n}`})," en donde ",e.jsx(a,{children:n`f`})," es constante."]}),e.jsxs(i,{concept:"Conjunto de nivel",children:["Sea ",e.jsx(a,{children:n`f\colon A\subseteq \mathbb{R}^n\to\mathbb{R}`})," y ",e.jsx(a,{children:n`c\in \mathbb{R}`}),", el ",e.jsxs("em",{children:["conjunto de nivel de ",e.jsx(a,{children:"f"})," en ",e.jsx(a,{children:"c"})]})," es el conjunto de todos los puntos en el dominio cuya imagen es ",e.jsx(a,{children:n`c`}),".",e.jsx(a,{block:!0,children:n`\text{conjunto de nivel de } f \text{ en } c = \{\bvec{x} \in A\mid f(\bvec{x})=c\} \subseteq \mathbb{R}^{n}`})]}),e.jsxs("p",{children:["En funciones escalares de tres variables los conjuntos de nivel son subconjuntos de ",e.jsx(a,{children:n`\mathbb{R}^{3}`})," y se denominan ",e.jsx("em",{children:"superficies de nivel"}),". Similarmente, en funciones escalares de dos variables los conjuntos de nivel se llaman ",e.jsx("em",{children:" curvas de nivel"})," por ser subconjuntos de ",e.jsx(a,{children:n`\mathbb{R}^{2}`}),"."]}),e.jsx("h4",{children:" Gráficas de funciones escalares de dos variables"}),e.jsxs("p",{children:["Se estudian con más especificidad las gráficas de funciones escalares de dos variables, debido a que, por ser subconjuntos de ",e.jsx(a,{children:n`\mathbb{R}^{3}`}),", se pueden visualizar en el espacio tridimensional y dibujar en el plano. Para todas las demás funciones escalares de múltiples variables, es complicado siquiera imaginar cómo se ven sus gráficas."]}),e.jsxs("p",{children:["Cada curva de nivel de una función definida en ",e.jsx(a,{children:n`\mathbb{R}^{2}`}),", de forma ",e.jsx(a,{children:n`f(x, y) = z`}),", se obtiene asignándole un valor constante ",e.jsx(a,{children:n`c \in \mathbb{R}`})," a la variable ",e.jsx(a,{children:n`z`}),". Así, toda curva de nivel es la intersección entre la superficie que es gráfica de la función y el plano ",e.jsx(a,{children:n`z=c`}),", por lo que son paralelas al plano ",e.jsx(a,{children:n`xy`}),"."]}),e.jsxs("p",{children:['Tiene sentido entonces pensar en las curvas de nivel como "rebanadas horizontales" de la superficie. Al unir todas las curvas de nivel se obtiene la gráfica de la función. Análogamente, tiene sentido pensar también en "rebanadas verticales" de la superficie, que son las ',e.jsx("em",{children:"secciones"})," de la gráfica."]}),e.jsxs(i,{concept:"Sección",children:["Sea ",e.jsx(a,{children:n`f\colon A\subseteq\mathbb{R}^{2}\to\mathbb{R}`})," una función escalar de dos variables, una ",e.jsx("em",{children:" sección"})," de la gráfica de ",e.jsx(a,{children:n`f`})," es la intersección de la gráfica con un plano vertical."]}),e.jsxs("p",{children:["Las secciones se pueden obtener de dos maneras: o asignándole un valor constante a la variable ",e.jsx(a,{children:n`x`}),", para obtener una sección paralela al plano ",e.jsx(a,{children:n`yz`}),", o asignándole un valor constante a la variable ",e.jsx(a,{children:n`y`}),", obteniendo una sección paralela al plano ",e.jsx(a,{children:n`xz`}),". Si se establece ",e.jsx(a,{children:n`x=a`}),", la sección obtenida será la intersección entre ese plano y la superficie; análogamente, al fijar ",e.jsx(a,{children:n`y=b`}),", la sección obtenida es la intersección entre la superficie y el plano ",e.jsx(a,{children:n`y=b`}),"."]}),e.jsx("p",{children:"Con eso en mente, para dibujar la gráfica de una función escalar de dos variables se siguen los siguientes pasos:"}),e.jsxs("ol",{children:[e.jsxs("li",{children:[" Graficar las curvas de nivel de la función en ",e.jsx(a,{children:n`\mathbb{R}^{2}`}),"."]}),e.jsxs("li",{children:[" Graficar las secciones de la función en ",e.jsx(a,{children:n`\mathbb{R}^{3}`}),"."]}),e.jsxs("li",{children:[" Graficar la superficie en ",e.jsx(a,{children:n`\mathbb{R}^{3}`}),"."]})]})]}),e.jsxs(l,{title:"Límites de múltiples variables",children:[e.jsxs("p",{children:["Para estudiar formalmente los límites con múltiples variables, es necesario definir el concepto de vecindad de un punto en ",e.jsx(a,{children:n`\mathbb{R}^{n}`}),". Para ello, la próxima sección se ocupa de definir conjuntos abiertos y cerrados"]}),e.jsx("h3",{children:"Conjuntos con valores reales"}),e.jsxs("p",{children:["Los conjuntos con valores reales son subconjuntos de ",e.jsx(a,{children:n`\mathbb{R}^{n}`}),". Los elementos de un conjunto con valores reales ",e.jsx(a,{children:n`A \subseteq\mathbb{R}^{n}`})," pueden ser escalares, si ",e.jsx(a,{children:n`n=1`}),", o tuplas de ",e.jsx(a,{children:n`n`})," elementos de forma",e.jsx(a,{block:!0,children:n`\bvec{x} = (x_1,x_2,\ldots,x_n) \in A \subseteq \mathbb{R}^{n}`}),"Dichas tuplas de ",e.jsx(a,{children:n`n`})," elementos pueden ser interpretadas como puntos o como vectores."]}),e.jsx("h4",{children:"Conjuntos abiertos"}),e.jsxs("p",{children:["Antes de entrar en detalle con los conjuntos abiertos, es necesario definir el concepto de entorno. Para ello, vale la pena tener presente la noción de distancia entre dos puntos en ",e.jsx(a,{children:n`\mathbb{R}^{n}`}),"."]}),e.jsxs(s,{children:["Al igual que la distancia entre dos valores ",e.jsx(a,{children:"a, b in mathbb{R}"}),"se puede expresar matemáticamente por ",e.jsx(a,{children:"|a-b|"})," o por ",e.jsx(a,{children:"|b-a|"}),", la distancia entre dos puntos ",e.jsx(a,{children:n`\bvec{v}, \bvec{w} \in \mathbb{R}^{n}`})," se puede expresar por ",e.jsx(a,{children:n`\norm{\bvec{v}-\bvec{w}}`})," o por ",e.jsx(a,{children:n`\norm{\bvec{w}-\bvec{v}}`}),". Es conveniente leer ",e.jsx(a,{children:n`\norm{\bvec{v}-\bvec{w}}`}),' como "la distancia entre ',e.jsx(a,{children:n`\bvec{v}`})," y ",e.jsx(a,{children:n`\bvec{w}`}),'".']}),e.jsxs("p",{children:["Se puede definir un conjunto de puntos a partir de un punto específico, que contenga a todos los puntos en ",e.jsx(a,{children:n`\mathbb{R}^{n}`})," cuya distancia al punto dado sea estrictamente menor a un determinado valor."]}),e.jsxs(i,{concept:"Entorno",children:["Sea ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{n}`})," un punto y ",e.jsx(a,{children:n`\varepsilon \in \mathbb{R}_{>0}`})," un escalar. Un ",e.jsx("em",{children:"entorno"})," con centro en ",e.jsx(a,{children:n`\bvec{v}`})," y radio ",e.jsx(a,{children:n`\varepsilon`})," se denota por ",e.jsx(a,{children:n`B_{\varepsilon}(\bvec{v})`})," y es el conjunto dado por",e.jsx(a,{block:!0,children:n`B_{\varepsilon}(\bvec{v}) = \{\bvec{x}\in\mathbb{R}^{n}\colon\norm{\bvec{x}-\bvec{v}} < \varepsilon\}.`})]}),e.jsxs("p",{children:["La interpretación geométrica de un entorno depende de ",e.jsx(a,{children:n`n`}),". Para ",e.jsx(a,{children:n`n=1`}),", el entorno ",e.jsx(a,{children:n`B_{\varepsilon}(v)`})," es el intervalo abierto ",e.jsx(a,{children:n`(v-\varepsilon,v+\varepsilon)`}),". Para ",e.jsx(a,{children:n`n=2`}),", es un círculo con centro ",e.jsx(a,{children:n`\bvec{v}`})," y radio ",e.jsx(a,{children:n`\varepsilon`})," que no incluye su circunferencia. A eso se le denomina ",e.jsx("em",{children:"disco abierto"}),"."]}),e.jsxs(i,{concept:"Disco abierto",children:["Sea ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{2}`})," un punto y ",e.jsx(a,{children:n`\varepsilon \in \mathbb{R}`})," un escalar tal que ",e.jsx(a,{children:n`\varepsilon>0`}),". Un ",e.jsx("em",{children:"disco abierto"})," con radio ",e.jsx(a,{children:n`\varepsilon`})," y centro en ",e.jsx(a,{children:n`\bvec{v}`})," es un entorno en ",e.jsx(a,{children:n`\mathbb{R}^{2}`})," de la forma",e.jsx(a,{block:!0,children:n`B_\varepsilon(\bvec{v})=\{\bvec{x}\in\mathbb{R}^{2}\colon\norm{\bvec{x}-\bvec{v}} < \varepsilon\}.`}),"Si ",e.jsx(a,{children:n`\bvec{v}=(v_x,v_y)`}),", el disco abierto se describe en coordenadas cartesianas como",e.jsx(a,{block:!0,children:n`B_\varepsilon(v_x,v_y)=\{(x,y)\colon (x-v_x)^2+(y-v_y)^2<\varepsilon^2\}.`})]}),e.jsxs("p",{children:["Para ",e.jsx(a,{children:n`n=3`}),", el conjunto es el interior de una esfera con centro ",e.jsx(a,{children:n`\bvec{v}`})," y radio ",e.jsx(a,{children:n`\varepsilon`})," excluyendo su borde."]}),e.jsxs(i,{concept:"Bola abierta",children:["Sea ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{3}`})," un punto y ",e.jsx(a,{children:n`\varepsilon \in \mathbb{R}`})," un escalar tal que ",e.jsx(a,{children:n`\varepsilon>0`}),". Una ",e.jsx("em",{children:"bola abierta"})," con radio ",e.jsx(a,{children:n`\varepsilon`})," y centro en ",e.jsx(a,{children:n`(\bvec{v})`})," es un entorno en ",e.jsx(a,{children:n`\mathbb{R}^{3}`})," de la forma",e.jsx(a,{block:!0,children:n`B_\varepsilon(\bvec{v})=\{\bvec{x}\in\mathbb{R}^{3}\colon\norm{\bvec{x}-\bvec{v}} < \varepsilon\}.`}),"Si ",e.jsx(a,{children:n`\bvec{v}=(v_x,v_y,v_z)`}),", la bola abierta se describe en coordenadas cartesianas como",e.jsx(a,{block:!0,children:n`B_\varepsilon(v_x,v_y)=\{(x,y,z)\colon (x-v_x)^2+(y-v_y)^2+(z-v_z)^2<\varepsilon^2\}.`})]}),e.jsx("p",{children:"A partir de un entorno, se define un conjunto abierto."}),e.jsxs(i,{concept:"Conjunto abierto",children:[e.jsx(a,{children:n`U\subseteq \mathbb{R}^{n}`})," es un ",e.jsx("em",{children:"conjunto abierto"})," si para todo punto ",e.jsx(a,{children:n`\bvec{v}\in U`})," existe un entorno centrado en ese punto con radio ",e.jsx(a,{children:n`\varepsilon \in \mathbb{R}_{>0}`}),".",e.jsx(a,{block:!0,children:n`\{\bvec{x}\in\mathbb{R}^{n}\colon\norm{\bvec{x}-\bvec{v}} < \varepsilon\}\subseteq U.`})]}),e.jsx("p",{children:"Intuitivamente, un conjunto abierto es un conjunto sin borde, pues para cada punto en el conjunto, siempre se puede encontrar un entorno."}),e.jsxs(d,{children:["Para denotar un conjunto abierto cualquiera generalmente se usa la letra mayúscula ",e.jsx(a,{children:n`U`}),"."]}),e.jsxs("p",{children:["El conjunto vacío ",e.jsx(a,{children:n`\varnothing`})," es abierto. También lo es el conjunto ",e.jsx(a,{children:n`\mathbb{R}^{n}`})," para todo ",e.jsx(a,{children:n`n \in \mathbb{N}\setminus\{0\}`}),"."]}),e.jsxs(i,{concept:"Vecindad de un punto",children:["Sea ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{n}`}),", una ",e.jsx("em",{children:"vecindad"})," de ",e.jsx(a,{children:n`\bvec{v}`})," es cualquier conjunto abierto ",e.jsx(a,{children:n`U`})," al que pertenezca ",e.jsx(a,{children:n`\bvec{v}`}),"."]}),e.jsxs("p",{children:["Un punto ",e.jsx(a,{children:n`\bvec{v}\in U`})," es un punto frontera de ",e.jsx(a,{children:n`U\subset \mathbb{R}^{n}`})," si para todo ",e.jsx(a,{children:n`\varepsilon >0`}),", todas sus vecindades intersecan a ",e.jsx(a,{children:n`U`})," e intersecan a ",e.jsx(a,{children:n`U^\complement`}),". Todos los puntos frontera forman lo que intuitivamente es el borde de ",e.jsx(a,{children:n`U`}),"."]}),e.jsxs(i,{concept:"Frontera de un conjunto",children:["Sea ",e.jsx(a,{children:n`A\subset\mathbb{R}^{n}`})," un conjunto, su ",e.jsx("em",{children:"frontera"}),", denotada ",e.jsx(a,{children:n`\partial A`}),", es el conjunto de todos los puntos ",e.jsx(a,{children:n`\bvec{v}`})," tales que todas sus vecindades contienen como mínimo un punto en ",e.jsx(a,{children:n`A`})," y un punto en ",e.jsx(a,{children:n`A^\complement`}),"."]}),e.jsxs("p",{children:["Nótese en la definición de frontera que los puntos en la frontera de un conjunto pueden ser o no elementos del conjunto. ",e.jsx(a,{children:n`U`})," es un conjunto abierto si y solamente si no contiene a ",e.jsx(a,{children:n`\partial U`}),"."]}),e.jsxs(s,{children:["Como se estudian conjuntos con valores reales, el complemento de un conjunto se toma respecto a ",e.jsx(a,{children:n`\mathbb{R}^{n}`}),". Es decir, sea ",e.jsx(a,{children:n`A \in \mathbb{R}^{n}`}),",",e.jsx(a,{block:!0,children:n`A^\complement = \mathbb{R}^{n} \setminus A.`})]}),e.jsx("h4",{children:"Conjuntos cerrados"}),e.jsx("p",{children:"Un entorno que contiene su borde es un entorno cerrado."}),e.jsxs(i,{concept:"Entorno cerrado",children:["Sea ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{n}`})," un punto y ",e.jsx(a,{children:n`\varepsilon \in \mathbb{R}`})," un escalar tal que ",e.jsx(a,{children:n`\varepsilon>0`}),". Un ",e.jsx("em",{children:"entorno cerrado"})," con centro de ",e.jsx(a,{children:n`\bvec{v}`})," y radio ",e.jsx(a,{children:n`\varepsilon`})," está dado por",e.jsx(a,{block:!0,children:n`\{\bvec{x}\in\mathbb{R}^{n}\colon\norm{\bvec{x}-\bvec{v}} \leq \varepsilon\}.`})]}),e.jsxs("p",{children:["Al igual que sucede con los entornos (abiertos), la interpretación geométrica de un entorno cerrado depende de ",e.jsx(a,{children:n`n`}),". Para ",e.jsx(a,{children:n`n=1`}),", el entorno cerrado con centro ",e.jsx(a,{children:n`v`})," y radio ",e.jsx(a,{children:n`\varepsilon`})," es el intervalo cerrado ",e.jsx(a,{children:n`[v-\varepsilon,v+\varepsilon].`}),". Se definen el disco cerrado y la bola cerrada con base en el entorno cerrado, de forma análoga a como se definieron antes el disco abierto y la bola abierta."]}),e.jsxs(s,{children:["La diferencia entre las definiciones de entorno, disco abierto, bola abierta y las de entorno cerrado, disco cerrado y bola cerrada es simplemente que en las primeras, siempre se usa el operador menor que, ",e.jsx(a,{children:n`<`}),", mientras que en las segundas se emplea siempre el operador menor o igual que, ",e.jsx(a,{children:n`\leq`}),"."]}),e.jsxs(i,{concept:"Disco cerrado",children:["Sea ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{2}`})," un punto y ",e.jsx(a,{children:n`\varepsilon \in \mathbb{R}`})," un escalar tal que ",e.jsx(a,{children:n`\varepsilon>0`}),". Un ",e.jsx("em",{children:"disco cerrado"})," con radio ",e.jsx(a,{children:n`\varepsilon`})," y centro en ",e.jsx(a,{children:n`(\bvec{v})`})," es un entorno cerrado en ",e.jsx(a,{children:n`\mathbb{R}^{2}`})," de la forma",e.jsx(a,{block:!0,children:n`\{\bvec{x}\in\mathbb{R}^{2}\colon\norm{\bvec{x}-\bvec{v}} \leq \varepsilon\}.`}),"Si ",e.jsx(a,{children:n`\bvec{v}=(v_x,v_y)`}),", el disco cerrado se describe en coordenadas cartesianas como",e.jsx(a,{block:!0,children:n`\{(x,y)\colon (x-v_x)^2+(y-v_y)^2\leq\varepsilon^2\},`}),"de forma que el disco contiene a su frontera, ",e.jsx(a,{children:n` (x-v_x)^2+(y-v_y)^2=\varepsilon^2 `}),"."]}),e.jsxs(i,{concept:"Bola cerrada",children:["Sea ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{3}`})," un punto y ",e.jsx(a,{children:n`\varepsilon \in \mathbb{R}`})," un escalar tal que ",e.jsx(a,{children:n`\varepsilon>0`}),". Una ",e.jsx("em",{children:"bola cerrada"})," con radio ",e.jsx(a,{children:n`\varepsilon`})," y centro en ",e.jsx(a,{children:n`(\bvec{v})`})," es un entorno en ",e.jsx(a,{children:n`\mathbb{R}^{3}`})," de la forma",e.jsx(a,{block:!0,children:n`\{\bvec{x}\in\mathbb{R}^{3}\colon\norm{\bvec{x}-\bvec{v}} \leq \varepsilon\}.`}),"Si ",e.jsx(a,{children:n`\bvec{v}=(v_x,v_y,v_z)`}),", la bola abierta se describe en coordenadas cartesianas como",e.jsx(a,{block:!0,children:n`\{(x,y,z)\colon (x-v_x)^2+(y-v_y)^2+(z-v_z)^2 \leq \varepsilon^2\}.`}),"Nótese que contiene a su frontera, ",e.jsx(a,{children:n` (x-v_x)^2+(y-v_y)^2+(z-v_z)^2 = \varepsilon^2`}),"."]}),e.jsx("p",{children:"Un conjunto que contiene su borde es cerrado."}),e.jsxs(i,{concept:"Conjunto cerrado",children:[e.jsx(a,{children:n`C\subset \mathbb{R}^{n}`}),"  es un ",e.jsx("em",{children:"conjunto cerrado"})," si para todo punto ",e.jsx(a,{children:n`\bvec{v}\in C`})," existe un entorno cerrado centrado en ese punto con radio ",e.jsx(a,{children:n`\varepsilon >0`}),".",e.jsx(a,{block:!0,children:n`\{\bvec{x}\in\mathbb{R}^{n}\colon\norm{\bvec{x}-\bvec{v}} \leq \varepsilon\}\subseteq C.`})]}),e.jsxs("p",{children:["Naturalmente, se cumple que ",e.jsx(a,{children:n`C \subset \mathbb{R}^{n}`})," es un ",e.jsx("em",{children:"conjunto cerrado"})," si y solamente si ",e.jsx(a,{children:n`C^\complement`})," es un conjunto abierto."]}),e.jsxs(d,{children:["Para denotar un conjunto cerrado cualquiera generalmente se usa la letra mayúscula ",e.jsx(a,{children:n`C`}),"."]}),e.jsxs(i,{concept:"Conjunto acotado",children:["Sea ",e.jsx(a,{children:n`A\in \mathbb{R}^{n}`})," un conjunto, es un ",e.jsx("em",{children:"conjunto acotado"})," si existe un entorno centrado en el origen tal que ",e.jsx(a,{children:n`A`})," está contenido en él. ",e.jsx(a,{children:n`A`})," es acotado si existe ",e.jsx(a,{children:n`N>0`})," tal que",e.jsx(a,{block:!0,children:n`A \subseteq B_N(\bvec{0})`})]}),e.jsxs("p",{children:["Un conjunto acotado no puede ser infinito, pues está encerrado por un intervalo (en ",e.jsx(a,{children:n`\mathbb{R}`}),"), un círculo (en ",e.jsx(a,{children:n`\mathbb{R}^{2}`}),"), una bola (en ",e.jsx(a,{children:n`\mathbb{R}^{3}`}),") o en general un entorno."]}),e.jsxs("p",{children:["Juntando las definiciones de conjunto cerrado y conjunto acotado se llega al concepto de ",e.jsx("em",{children:"compacto"}),"."]}),e.jsxs(i,{concept:"Compacto",children:["Sea ",e.jsx(a,{children:n`C\in \mathbb{R}^{n}`})," un conjunto, es ",e.jsx("em",{children:"compacto"})," si es un conjunto cerrado y acotado."]}),e.jsx("p",{children:"Todo entorno cerrado es compacto."}),e.jsx("h3",{children:"Límites de múltiples variables"}),e.jsx(c,{children:"La siguiente definición resulta fácil de entender si se comprende con claridad la definición de límite en una variable. De lo contrario, la definición no es intuitiva en absoluta. Se recomienda revisar la definición de límite en una variable antes de continuar."}),e.jsx("p",{children:"La definición de límite de múltiples variables es una generalización de la definición de límite en una variable. Varía en que el dominio de la función tiene que ser un conjunto abierto y en que el elemento al que tiende la variable debe encontrarse o bien en el dominio o bien en su frontera."}),e.jsxs(i,{concept:"Límite de múltiples variables",children:["Dado un conjunto abierto ",e.jsx(a,{children:n`U\subseteq \mathbb{R}^{n}`}),", una función escalar de múltiples variables ",e.jsx(a,{children:n`f\colon U \to\mathbb{R}^{m}`})," y vectores ",e.jsx(a,{children:n`\bvec{u} \in U \cup \partial U`})," y ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{m}`}),". El ",e.jsx("em",{children:"límite"})," cuando ",e.jsx(a,{children:n`\bvec{x}`})," tiende a ",e.jsx(a,{children:n`\bvec{u}`})," se define como",e.jsx(a,{block:!0,children:n`\Big(\lim_{\bvec{x}\to \bvec{u}} f(\bvec{x}) = \bvec{v}\Big) \iff \Big(\forall \varepsilon \in \mathbb{R}_{>0} \ \exists \delta \in \mathbb{R}_{>0} \colon 0 < \norm{\bvec{x}-\bvec{u}} < \delta \implies \norm{f(\bvec{x})-\bvec{v}}< \varepsilon, \forall \bvec{x} \in U \Big).`})]}),e.jsx("h3",{children:"Continuidad en varias variables"}),e.jsx("p",{children:"También se generaliza el concepto de continuidad para funciones de múltiples variables."}),e.jsxs(i,{concept:"Continuidad en varias variables",children:["La función de múltiples variables ",e.jsx(a,{children:n`f`})," es continua en ",e.jsx(a,{children:n`\bvec{v} \in \dom f`})," si",e.jsx(a,{block:!0,children:n`\lim_{\bvec{x}\to\bvec{v}} f(\bvec{x}) = f(\bvec{v}).`})]}),e.jsx("p",{children:"Análogamente a la definición de continuidad en un intervalo, una función de múltiples variables es continua en un conjunto abierto si lo es en cada punto de ese conjunto."}),e.jsxs(i,{concept:"Continuidad en un conjunto abierto",children:["La función de múltiples variables ",e.jsx(a,{children:n`f`})," es continua en el conjunto abierto ",e.jsx(a,{children:n`B_\varepsilon(\bvec{v})`})," si lo es en cada punto que pertenece al conjunto."]}),e.jsx("h4",{children:"Propiedades de las funciones continuas de múltiples variables"}),e.jsxs("p",{children:["Sean ",e.jsx(a,{children:n`\bvec{F},\bvec{G}\colon U \subseteq \mathbb{R}^{m} \to \mathbb{R}^{n}`})," funciones vectoriales (o escalares) continuas en ",e.jsx(a,{children:n`\bvec{v} \in U`})," y sea ",e.jsx(a,{children:n`c \in \mathbb{R}`}),", entonces las siguientes funciones son continuas en ",e.jsx(a,{children:n`\bvec{v}`}),":"]}),e.jsxs("ul",{children:[e.jsxs("li",{children:[" ",e.jsx(a,{children:n`\bvec{F}+\bvec{G}`}),"."]}),e.jsxs("li",{children:[" ",e.jsx(a,{children:n`\bvec{F}\cdot \bvec{G}`}),"."]}),e.jsxs("li",{children:[" ",e.jsx(a,{children:n`\bvec{F}\times \bvec{G}, \quad \text{si } n=3`}),"."]}),e.jsxs("li",{children:[" ",e.jsx(a,{children:n`c \, \bvec{F}`}),"."]})]}),e.jsxs("p",{children:["Si además de lo anterior se cumple que ",e.jsx(a,{children:n`n=1`}),", de forma que las funciones son escalares y las denoto ahora por ",e.jsx(a,{children:"f"})," y ",e.jsx(a,{children:"g"}),", y se cumple que ",e.jsx(a,{children:n`g(\bvec{v})\neq 0`}),", también es continua la función"]}),e.jsx("ul",{children:e.jsxs("li",{children:[" ",e.jsx(a,{children:n`f/g`}),"."]})}),e.jsx("h3",{children:"Cálculo de límites de múltiples variables"}),"Se presenta un método general para calcular límites de funciones escalares de múltiples variables. Se toma el caso de dos variables, pero el método es generalizable a cualquier número de variables.",e.jsx("h4",{children:"Cálculo de límites para funciones escalares con dos variables"}),"Sea ",e.jsx(a,{children:n`f\colon\mathbb{R}^{2}\to\mathbb{R}`})," y ",e.jsx(a,{children:n`a,b\in\mathbb{R}`}),", los límites de ",e.jsx(a,{children:n`f`})," son de la forma ",e.jsx(a,{block:!0,children:n`\lim_{(x,y)\to(a,b)} f(x,y) = c.`}),e.jsxs("p",{children:[e.jsx("b",{children:"1. Intentar evaluar el límite."})," Si la función es continua, reemplazar el valor de ",e.jsx(a,{children:n`x`})," por ",e.jsx(a,{children:n`a`})," y el de ",e.jsx(a,{children:n`y`})," por ",e.jsx(a,{children:n`b`})," para evaluar el límite. Si el cálculo arroja un escalar, se obtuvo la respuesta, el límite era fácil; de lo contrario, hay que usar uno de los siguientes 4 métodos. Se sugiere probarlos en orden."]}),e.jsxs("p",{children:[e.jsx("b",{children:"2. Usar coordenadas polares."})," Las coordenadas polares representan los puntos con base en su distancia a un polo (radio). Si se coloca el polo en el punto ",e.jsx(a,{children:n`(a,b)`}),", las coordenadas polares contemplan todos los puntos a cierta distancia de ",e.jsx(a,{children:n`(a,b)`}),", por lo que permiten acercarse al punto desde todas las direcciones simultáneamente. Esto puede facilitar la evaluación del límite."]}),e.jsxs("p",{children:["Para que ",e.jsx(a,{children:n`(a,b)`})," sea el polo, se debe realizar el siguiente cambio de variables:",e.jsx(a,{block:!0,children:n`\begin{gather*}
	x = a+r\cos\theta\\
	y = b+r\sin\theta.
\end{gather*}`}),"Con ese cambio, ahora se evalúa el límite cuando los puntos se acercan al polo, es decir, cuando el radio tiende a ",e.jsx(a,{children:n`0`})," para cualquier ángulo:",e.jsx(a,{block:!0,children:n`\lim_{r\to 0} f(r,\theta), \quad \forall \theta.`}),"Eso es un límite univariado. Al evaluarlo, puede pasar que"]}),e.jsxs("ul",{children:[e.jsx("li",{children:" Se obtiene un escalar."}),e.jsxs("li",{children:[" Se obtiene una función ",e.jsx(a,{children:n`g(\theta)`}),"."]}),e.jsxs("ul",{children:[e.jsxs("li",{children:[" Si la función tiene la forma ",e.jsx(a,{children:n`0 \, g(\theta)`})," y se sabe que ",e.jsx(a,{children:n`g(\theta)`})," ",e.jsx("b",{children:"es acotada por valores finitos"}),", el límite es 0. Por ejemplo, ",e.jsx(a,{block:!0,children:n`\lim_{r\to0}0(\sin^5\theta) = 0`})," porque ",e.jsx(a,{children:n`-1\leq\sin^5\theta\leq 1.`})]}),e.jsxs("li",{children:[" Si ",e.jsx(a,{children:n`g(\theta)`})," no es acotada, este método no sirvió y probablemente el límite no existe. Se debe entonces intentar demostrar su inexistencia usando alguno de los métodos siguientes."]}),e.jsxs(s,{children:["Si existen dos valores de ángulos ",e.jsx(a,{children:n`\theta_1`})," y ",e.jsx(a,{children:n`\theta_2`})," tal que evaluados en ",e.jsx(a,{children:n`g(\theta)`})," arrojan escalares distintos, se demuestra la inexistencia del límite."]})]})]}),e.jsxs("p",{children:[e.jsx("b",{children:"3. Demostrar la inexistencia del límite tomando distintas direcciones."})," En un límite univariado, solo es posible acercarse al punto por dos direcciones: izquierda y derecha. En contraposición, en límites de múltiples variables es posible acercarse al punto desde infinitas direcciones. Si acercarse al punto desde dos direcciones distintas da valores disímiles para el límite, el límite no existe."]}),e.jsxs("p",{children:["Para un límite que tiende a ",e.jsx(a,{children:n`(a,b)`}),",",e.jsx(a,{block:!0,children:n`\displaystyle \lim_{(x,y)\to(a,b)} f(x,y)`}),"se puede tomar cualquier función ",e.jsx(a,{children:n`f(a)=b`})," como una dirección (e.g., ",e.jsx(a,{children:n`y=b`}),", ",e.jsx(a,{children:n`y=x+b-a`}),", ",e.jsx(a,{children:n`y=x^2+b-a^2`}),", etcétera). En este caso, se está siguiendo la curva de la función seleccionada para aproximarse al punto del límite desde esa dirección. Al reemplaza ",e.jsx(a,{children:n`y`})," en el límite por alguna dirección, se consigue un límite univariado. Si se realiza este proceso dos o más veces, se calcula el límite univariado, y se encuentran dos límites con valores distintos, entonces el límite inicial no existe."]}),e.jsx(c,{children:"Que dos o más de esos límites sean iguales no indica nada sobre la existencia del límite y mucho menos que el límite sea igual a ese valor."}),e.jsxs("p",{children:[e.jsx("b",{children:"4. Demostrar la inexistencia del límite fijando variables. "})," Es una aplicación del concepto anterior. Se toma un valor constante ",e.jsx(a,{children:n`a`})," para ",e.jsx(a,{children:n`x`})," y se evalúa el límite ",e.jsx(a,{children:n`\displaystyle \lim_{(a,y)\to(a,b)} f(x,y)`}),". Tras eso, se fija ",e.jsx(a,{children:n`y`})," en ",e.jsx(a,{children:n`b`})," y se evalúa el límite ",e.jsx(a,{children:n`\displaystyle \lim_{(x,b)\to(a,b)} f(x,y)`}),". Si los límites son distintos, entonces el límite inicial no existe. Es útil para los límites que tienden al origen porque se fija cada variable en ",e.jsx(a,{children:n`0`})," y las cosas se cancelan."]}),e.jsx(c,{children:"Nuevamente, que los límites dan iguales no indica nada sobre la existencia del límite."}),e.jsxs("p",{children:["Como generalización de lo anterior, dado un límite de ",e.jsx(a,{children:"n"})," variables ",e.jsx(a,{block:!0,children:n`\lim_{(x_1,x_2,\ldots,x_n) \to (a_1,a_2,\ldots,a_n)} f(\bvec{x}),`}),"se pueden establecer valores constantes arbitrarios para ",e.jsx(a,{children:n`n-1`})," variables y obtener el límite ",e.jsx(a,{block:!0,children:n`\lim_{(x_1,a_2,\ldots,a_n) \to (a_1,a_2,\ldots,a_n)} f(\bvec{x})`}),"que es un límite univariado sobre ",e.jsx(a,{children:n`x_1`}),". Se repite el proceso con cada variable, obteniendo ",e.jsx(a,{children:"n"})," límites univariados. Si al evaluar todos los límites, se obtienen dos o más límites con resultados diferentes, se prueba la inexistencia del límite inicial."]}),e.jsxs("p",{children:[e.jsx("b",{children:"5. Demostrar la existencia del límite usando la definición épsilon-delta. "}),"Si se tiene dominio sobre la definición formal de límite, se puede tomar la definición y determinar un ",e.jsx(a,{children:n`\delta`})," que garantice que la desigualdad se cumple para cada posible ",e.jsx(a,{children:n`\varepsilon`}),", demostrando así la existencia del límite."]}),e.jsxs(c,{children:["En las propiedades vi y vii se ponen condiciones para ",e.jsx(a,{children:n`n`}),". Esto es necesario para que en el espacio de llegada ",e.jsx(a,{children:n`\mathbb{R}^{n}`})," este definido el cociente (sólo definido en ",e.jsx(a,{children:n`n=1`}),") y el producto cruz (sólo definido en ",e.jsx(a,{children:n`n=3`}),")."]}),e.jsxs(s,{children:["En el límite del cociente, las funciones se denotan por ",e.jsx(a,{children:n`f`})," y ",e.jsx(a,{children:n`g`})," en lugar de ",e.jsx(a,{children:n`\bvec{F}`})," y ",e.jsx(a,{children:n`\bvec{G}`})," porque como ",e.jsx(a,{children:n`n=1`}),", su codominio es ",e.jsx(a,{children:n`\mathbb{R}`})," y las funciones son funciones escalares."]}),e.jsxs(s,{children:["En el límite de una función compuesta, las variables de ",e.jsx(a,{children:n`\bvec{F}`})," y ",e.jsx(a,{children:n`\bvec{H}`})," se denotan por letras distintas para enfatizar que ",e.jsx(a,{children:n`\bvec{x}\in\mathbb{R}^{m}`})," mientras que ",e.jsx(a,{children:n`\bvec{y}\in\mathbb{R}^{n}`}),". Se puede entender el límite de una función compuesta pensando en que ",e.jsx(a,{children:n`\bvec{F}`})," toma valores cerca de ",e.jsx(a,{children:n`\bvec{u}`})," y los lleva a ",e.jsx(a,{children:n`\bvec{v}`})," y luego ",e.jsx(a,{children:n`\bvec{H}`})," toma valores cerca de ",e.jsx(a,{children:n`\bvec{v}`})," y los lleva a ",e.jsx(a,{children:n`\bvec{w}`}),"."]})]}),e.jsxs(l,{title:"Derivación de funciones escalares de múltiples variables",children:[e.jsx("h3",{children:"La derivada parcial"}),e.jsxs("p",{children:["Al definir la ",f("derivada para funciones escalares de una variable",j,"derivada"),", se deriva sobre la única variable que tiene la función. En el caso de funciones escalares de múltiples variables, es posible derivar la función con respecto a cada una de sus variables de forma independiente. A esa operación se le denomina derivada parcial."]}),e.jsxs(i,{concept:"Derivada parcial",children:["Sean ",e.jsx(a,{children:n`U \subseteq \mathbb{R}^{n}`})," un conjunto abierto, ",e.jsx(a,{children:n`f\colon U \to \mathbb{R}`})," una función escalar de ",e.jsx(a,{children:n`n`})," variables y ",e.jsx(a,{children:n`\bvec{v}\in U`})," un punto. La ",e.jsx("em",{children:"derivada parcial"})," de ",e.jsx(a,{children:n`f`})," con respecto a la i-ésima variable ",e.jsx(a,{children:n`x_i`}),", donde ",e.jsx(a,{children:n`i \leq n`}),", se define como",e.jsx(a,{block:!0,children:n`\parder{f}{x_i} = \lim_{h\to 0} \frac{f(x_1,x_2,\ldots,x_{i-1},x_i+h,x_{i+1},\ldots,x_n)-f(x_1,x_2,\ldots,x_n)}{h}.`}),"Si y solamente si el límite existe."]}),e.jsxs("p",{children:["La definición de derivada parcial es análoga a la definición de derivada: en el numerador, sólo se suma ",e.jsx(a,{children:n`h`})," a la variable con respecto a la cual se está derivando. La derivada parcial ",e.jsx(a,{children:n`\partial f /\partial x_i`})," indica cómo crece (o decrece) la función en la dirección de la variable ",e.jsx(a,{children:n`x_i`}),", es decir, respecto al eje cartesiano ",e.jsx(a,{children:n`x_i`}),". Para toda función escalar de múltiples variables, si esta es diferenciable, se pueden calcular sus derivadas parciales con respecto a cada una de sus variables. Nótese que la derivada parcial sólo está definida para funciones escalares."]}),e.jsxs("p",{children:["Para calcular la derivada parcial ",e.jsx(a,{children:n`\partial f /\partial x_i`}),", se hace uso de las reglas de derivación del cálculo diferencial tomando ",e.jsx(a,{children:n`x_i`})," como si fuera la única variable de la función y todas las demás variables como si fueran constantes. A causa de eso, el procedimiento para calcular una derivada parcial es el mismo que se sigue para calcular la derivada de una función escalar de una variable. Consecuentemente, la derivación parcial tiene las mismas propiedades que la derivación de funciones escalares de una variable."]}),e.jsxs(r,{children:["Partiendo de una función ",e.jsx(a,{children:n`f\colon U\subseteq \mathbb{R}^{3}\to \mathbb{R}`})," dada por ",e.jsx(a,{children:n`f(x,y,z)=\sin(x^2-y)+\mathrm{e}^{z^2}x`}),", hallar la derivada parcial para cada variable.",e.jsx(a,{block:!0,children:n`\begin{gather*}
		\parder{f}{x} = 2x\cos(x^2-x) + \mathrm{e}^{z^2}. \\
		\parder{f}{y} = -\cos(x^2-x). \\
		\parder{f}{z} = 2z\mathrm{e}^{z^2}x.
	\end{gather*}`})]}),e.jsxs("p",{children:["Sean ",e.jsx(a,{children:n`U \subseteq \mathbb{R}^{n}`})," un conjunto abierto y ",e.jsx(a,{children:n`f,g\colon U\to\mathbb{R}`})," funciones escalares de múltiples variables, si ",e.jsx(a,{children:n`\partial f / \partial x_i`})," y ",e.jsx(a,{children:n`\partial g / \partial x_i`})," existen, las propiedades de la derivada parcial respecto a cualquier variable ",e.jsx(a,{children:n`x_i`})," de ",e.jsx(a,{children:n`f`})," y ",e.jsx(a,{children:n`g`})," son idénticas a las propiedades de la derivada de funciones escalares de una variable:"]}),e.jsx("h4",{children:"Derivada parcial de enésimo orden"}),e.jsx("p",{children:"Al igual que pasa en la derivación de funciones escalares de una variable, existen derivadas parciales de múltiples órdenes. Sin embargo, como existe una derivada parcial por cada variable, se pueden calcular múltiples derivadas parciales de segundo orden y más aún de ordenes superiores."}),e.jsxs("p",{children:["Sean ",e.jsx(a,{children:n`U`})," un conjunto abierto y ",e.jsx(a,{children:n`f\colon U \subseteq \mathbb{R}^{n} \to \mathbb{R}`})," una función escalar diferenciable de ",e.jsx(a,{children:n`n`})," variables, para cada derivada parcial ",e.jsx(a,{children:n`\partial f /\partial x_i`}),", se puede calcular a su vez la derivada parcial para cada una de sus variables. A eso se le denomina ",e.jsx("em",{children:"segunda derivada parcial"})," o ",e.jsx("em",{children:"derivada parcial de segundo orden"})," y se debe especificar respecto a qué variable se calcula. La segunda derivada parcial con respecto a ",e.jsx(a,{children:n`x_j`})," de la derivada parcial con respecto a ",e.jsx(a,{children:n`x_i`})," de la función ",e.jsx(a,{children:n`f`})," se denota por",e.jsx(a,{block:!0,children:n`\begin{gather*}
	\frac{\partial f}{\partial x_j} \left(\frac{\partial f}{\partial x_i}\right)
	\frac{\partial^2 f}{\partial x_j \partial x_i}
\end{gather*}`}),"La segunda derivada parcial de ",e.jsx(a,{children:n`f`})," con respecto a ",e.jsx(a,{children:n`x_i`})," se denota por",e.jsx(a,{block:!0,children:n`\frac{\partial^2 f}{\partial^2 x_i}`})]}),e.jsxs(d,{children:["En ocasiones, la segunda derivada parcial de ",e.jsx(a,{children:n`f`})," con respecto a ",e.jsx(a,{children:n`x_j`})," y ",e.jsx(a,{children:n`x_i`})," se denota por ",e.jsx(a,{children:n`\partial x_j \partial x_i f `})," o por ",e.jsx(a,{children:n`F_{x_j\,x_i}`}),"."]}),e.jsxs("p",{children:["Derivar parcialmente una función ",e.jsx(a,{children:n`f`})," primero con respecto a una variable ",e.jsx(a,{children:n`x_i`})," y luego con respecto a otra variable ",e.jsx(a,{children:n`x_j`})," es igual a derivar primero con respecto a una variable ",e.jsx(a,{children:n`x_j`})," y luego con respecto a la variable ",e.jsx(a,{children:n`x_i`}),". Es decir,",e.jsx(a,{block:!0,children:n`\begin{gather*}
	\partial^2 f /\partial x_j \partial x_i = \partial^2 f /\partial x_i \partial x_j
\end{gather*}`}),"A esa propiedad se le denomina la ",e.jsx("em",{children:"simetría de la derivada parcial"}),"."]}),e.jsxs(r,{children:["Halle las segundas derivadas parciales de ",e.jsx(a,{children:n`f(x,y,z)=x^2\cos(y-z)`}),". Se hallan las derivadas parciales de primer orden:",e.jsx(a,{block:!0,children:n`\begin{gather*}
		\parder{f}{x} = 2x\cos(y-z) \\
		\parder{f}{y} = -x^2 \sin(y-z) \\
		\parder{f}{z} = x^2 \sin(y-z)
	\end{gather*}`}),"Se hallan las derivadas parciales de segundo orden de la derivada parcial con respecto a ",e.jsx(a,{children:n`x`}),":",e.jsx(a,{block:!0,children:n`\begin{gather*}
		\frac{\partial f^2}{\partial x^2} = 2 \cos(y-z) \\
		\frac{\partial f^2}{\partial y \partial x} = -2x\sin(y-z) \\
		\frac{\partial f^2}{\partial z \partial x} = 2x\sin(y-z) 
	\end{gather*}`}),"Se hallan las derivadas parciales de segundo orden de la derivada parcial con respecto a ",e.jsx(a,{children:n`y`}),":",e.jsx(a,{block:!0,children:n`\begin{gather*}
		\frac{\partial f^2}{\partial x \partial y} = -2x\sin(y-x) \\
		\frac{\partial f^2}{\partial y^2} =  -x^2 \cos(y-z) \\
		\frac{\partial f^2}{\partial z \partial y} =  x^2 \cos(y-z)
	\end{gather*}`}),"Se hallan las derivadas parciales de segundo orden de la derivada parcial con respecto a ",e.jsx(a,{children:n`z`}),":",e.jsx(a,{block:!0,children:n`\begin{gather*}
		\frac{\partial f^2}{\partial x \partial z} = 2x\sin(y-z) \\
		\frac{\partial f^2}{\partial y \partial z} = x^2 \cos(y-z) \\
		\frac{\partial f^2}{\partial z^2} = -x^2 \cos(y-z)
	\end{gather*}`})]}),e.jsxs("p",{children:["Dada una función escalar de ",e.jsx(a,{children:n`m`})," variables  ",e.jsx(a,{children:n`f\colon U\subseteq \mathbb{R}^{m}\to\mathbb{R}`}),", si la función de clase ",e.jsx(a,{children:n`C^{n}`})," tal que es ",e.jsx(a,{children:n`n`})," veces continuamente diferenciable, es posible calcular ",e.jsx(a,{children:n`m^n`})," ",e.jsx("em",{children:"derivadas parciales de enésimo orden"}),". Sin embargo, entre ellas hay varias repetidas por simetría de la derivada parcial. A razón de eso, el número de derivadas parciales de enésimo orden únicas para una función con ",e.jsx(a,{children:n`m`})," variables es un problema equivalente al número de formas en las cuales es posible distribuir ",e.jsx(a,{children:n`n`})," elementos en ",e.jsx(a,{children:n`m`})," contenedores. Haciendo uso de combinatoria, se llega a que la respuesta está dada por el siguiente coeficiente binomial:",e.jsx(a,{block:!0,children:n`\begin{pmatrix}
	n+m-1\\m-1
	\end{pmatrix}.`})]}),e.jsx("h3",{children:"Notación nabla"}),e.jsxs("p",{children:[e.jsx("em",{children:"Nabla"})," o ",e.jsx("em",{children:"del"}),", denotado por el símbolo ",e.jsx(a,{children:n`\nabla`}),", es el vector de operadores de derivadas parciales.",e.jsx(a,{block:!0,children:n`\nabla = \left(\frac{\partial}{\partial x_1},\frac{\partial}{\partial x_2},\ldots,\frac{\partial}{\partial x_n}\right).`}),"Haciendo uso de vectores unitarios de base estándar, nabla se define en el sistema coordenado cartesiano como",e.jsx(a,{block:!0,children:n`\nabla = \sum_{i=1}^n \bvec{e}_i \frac{\partial}{\partial x_i}.`})]}),e.jsxs("p",{children:["Nabla no es un vector, sino un ",e.jsx("em",{children:"operador vectorial"}),", por lo que sus propiedades se deben derivar con delicadeza. Nabla no tiene magnitud ni dirección, mas puede ser operado con funciones de múltiples variables para obtener un vector, o con vectores o escalares para obtener el vector cero. Están definidas para nabla la multiplicación por escalar y los productos punto y cruz."]}),e.jsxs("ul",{children:[e.jsx("li",{children:" La multiplicación de nabla por una función escalar da origen al gradiente."}),e.jsx("li",{children:" El producto punto de nabla con una función vectorial  da origen a la divergencia."}),e.jsx("li",{children:" El producto cruz de nabla con una función vectorial da origen al rotacional."})]}),e.jsx(c,{children:"Nabla no conmuta en el producto punto como sí lo hacen los vectores."}),e.jsxs("p",{children:["El número de componentes de nabla, ",e.jsx(a,{children:n`n`}),", está dado por el número de variables que tiene la función con la cuál está siendo operada. Para funciones de tres variables, nabla se define como",e.jsx(a,{block:!0,children:n`\begin{gather*}
	\nabla = \left(\frac{\partial}{\partial x},\frac{\partial}{\partial y},\frac{\partial}{\partial z}\right)\\
	\nabla = \uveci\frac{\partial}{\partial x} + \uvecj\frac{\partial}{\partial y} + \uvec{k}\frac{\partial}{\partial z}.
\end{gather*}`})]}),e.jsx("h3",{children:"El gradiente"}),e.jsx("p",{children:"El gradiente es la generalización de la derivada de funciones escalares de una variable para funciones escalares de múltiples variables. En general, derivar una función escalar consiste en calcular su gradiente, incluso para funciones escalares de una variable."}),e.jsxs(i,{concept:"Gradiente",children:["Sean ",e.jsx(a,{children:n`U \subseteq \mathbb{R}^{n}`})," un conjunto abierto y ",e.jsx(a,{children:n`f\colon U \to \mathbb{R}`})," una función escalar de múltiples variables, si todas las derivadas parciales ",e.jsx(a,{children:n` \partial f / \partial x_i `})," existen para ",e.jsx(a,{children:n`i \in \mathbb{N}\mid 1\leq i \leq n`}),", entonces el ",e.jsx("em",{children:"gradiente"})," de ",e.jsx(a,{children:n`f`}),", denotado por ",e.jsx(a,{children:n`\nabla f`}),", está dado por",e.jsx(a,{block:!0,children:n`\begin{align*}
	\nabla f &= \left(\frac{\partial}{\partial x_1},\frac{\partial}{\partial x_2},\ldots,\frac{\partial}{\partial x_n}\right)f\\
	\nabla f &= \left(\parder{f}{x_1},\parder{f}{x_2},\ldots,\parder{f}{x_n}\right)\\
	\nabla f &= \bvec{e}_1 \parder{f}{x_1} + \bvec{e}_2 \parder{f}{x_2} + \cdots + \bvec{e}_n \parder{f}{x_n}
\end{align*}`}),"donde los vectores ",e.jsx(a,{children:n`\bvec{e}_i`})," son los vectores unitarios de base estándar."]}),e.jsxs("p",{children:["Para una función ",e.jsx(a,{children:n`g\colon U \subseteq\mathbb{R}^{3}\to\mathbb{R}`}),", el gradiente se puede definir como:",e.jsx(a,{block:!0,children:n`\nabla g = \uveci \parder{f}{x} + \uvecj \parder{f}{y} + \uvec{k} \parder{f}{z}`})]}),e.jsxs("p",{children:["Calcular el gradiente de una función escalar de ",e.jsx(a,{children:n`n`})," variables resulta en un vector ",e.jsx(a,{children:n`\nabla f \in \mathbb{R}^{n}`}),". Si no se evalúa la gradiente en ningún punto, las componentes del vector son funciones escalares. Si se evalúa en un punto ",e.jsx(a,{children:n`\bvec{ \in \mathbb{R}^{n}}`}),", las componentes del vector ",e.jsx(a,{children:n`\nabla f (\bvec{v})`})," son números. Esto es análogo a lo que sucede con la derivada del cálculo diferencial: si se evalúa, es un número; de lo contrario, es una función escalar de una variable."]}),e.jsxs("p",{children:["El gradiente presenta las mismas propiedades de la derivada del cálculo diferencial (pues ",e.jsx("i",{children:"es"})," la derivada). Sean ",e.jsx(a,{children:n`U \subseteq \mathbb{R}^{n}`})," un conjunto abierto y ",e.jsx(a,{children:n`f,g\colon U\to\mathbb{R}`})," funciones escalares de múltiples variables, si ",e.jsx(a,{children:n`\nabla f`})," y ",e.jsx(a,{children:n`\nabla g`})," existen, se cumple que"]}),e.jsx("h4",{children:"Planos tangentes"}),e.jsx("p",{children:"El gradiente de una función siempre es normal a los conjuntos de nivel de la función. Ese hecho se utiliza para hallar planos tangentes a una superficie o superficie de nivel en un punto determinado."}),e.jsx("h5",{children:"Planos tangentes a superficies de nivel"}),e.jsxs("p",{children:["Sea ",e.jsx(a,{children:n`f`})," una función diferenciable ",e.jsx(a,{children:n`f\colon U\subseteq\mathbb{R}^{3}\to\mathbb{R}`})," y ",e.jsx(a,{children:n`d\in \mathbb{R}`}),", uno de sus conjuntos de nivel es ",e.jsx(a,{children:n`f(x,y,z)=d`}),", que es concretamente una superficie de nivel. Sea ",e.jsx(a,{children:n`(a,b,c)`})," un punto en la superficie de nivel, de forma que satisface ",e.jsx(a,{children:n` f(a,b,c)=d `}),". Para hallar el plano tangente a la superficie de nivel ",e.jsx(a,{children:n`f(x,y,z)=d`})," en el punto ",e.jsx(a,{children:n`(a,b,c)`}),", se usa el hecho de que el vector ",e.jsx(a,{children:n`\nabla f(a,b,c)`})," es normal a la superficie en el punto ",e.jsx(a,{children:n`(a,b,c)`}),". Se tiene entonces un vector normal al plano tangente y un punto en él, por lo que se puede escribir la ecuación del plano como",e.jsx(a,{block:!0,children:n`(x-a,y-b,z-c) \cdot (\nabla f(a,b,c)) = 0.`}),"Se iguala el producto punto a 0 para que el plano consista de todos los posibles vectores cuyo punto inicial es ",e.jsx(a,{children:n`(a,b,c)`}),", que están dados por ",e.jsx(a,{children:n` (x-a,y-b,z-c) `}),", que satisfagan ser perpendiculares al vector normal ",e.jsx(a,{children:n`\bvec{n}=\nabla f(a,b,c)`}),"."]}),e.jsx("h5",{children:"Planos tangentes a superficies"}),e.jsxs("p",{children:["Sea ",e.jsx(a,{children:n`f`})," una función diferenciable ",e.jsx(a,{children:n`f\colon U\subseteq\mathbb{R}^{2}\to\mathbb{R}`}),", su superficie está dada por ",e.jsx(a,{children:n`f(x,y)=z`}),". Dados ",e.jsx(a,{children:n`a,b \in U\subseteq \mathbb{R}`}),", se sabe que el punto ",e.jsx(a,{children:n`(a,b,f(a,b))`})," se encuentra en la superficie. Se quiere implementar el procedimiento para hallar planos tangentes a superficies de nivel. Para ello se define una función ",e.jsx(a,{children:n`g\colon U\subseteq\mathbb{R}^{3}\to\mathbb{R}`})," por",e.jsx(a,{block:!0,children:n`g(x,y,z)\coloneqq f(x,y)-z`}),"con lo que se reescribe la superficie \\(\\) como una superficie de nivel:",e.jsx(a,{block:!0,children:n`\begin{align*}
	f(x,y)&=z \\
	f(x,y)-z&=0 \\
	g(x,y,z)&=0 
\end{align*}`}),"Con eso, se puede usar el método para planos tangentes a superficies de nivel. Se obtiene la gradiente evaluada en el punto, ",e.jsx(a,{children:n`\nabla g(a,b,f(a,b))`})," y se escribe la ecuación del plano como",e.jsx(a,{block:!0,children:n`(x-a,y-b,z-f(a,b)) \cdot (\nabla g(a,b,f(a,b))) = 0.`})]}),e.jsxs(s,{children:["Si el gradiente de una función ",e.jsx(a,{children:n`f`})," evaluado en un punto sea igual a ",e.jsx(a,{children:n`\bvec{0}`}),", entonces el plano tangente a ",e.jsx(a,{children:n`f`})," en ese punto es paralelo al plano ",e.jsx(a,{children:n`xy`}),"."]}),e.jsx("h3",{children:"La derivada direccional"}),e.jsxs("p",{children:["La derivada direccional es la generalización de la derivación parcial. Dada una función escalar diferenciable ",e.jsx(a,{children:n`f\colon U\subseteq \mathbb{R}^{n}\to \mathbb{R}`}),",  la derivación parcial permite derivar ",e.jsx(a,{children:n`f`})," con respecto a sus ",e.jsx(a,{children:n`n`})," variables, es decir respecto a la dirección de cada uno de los ",e.jsx(a,{children:n`n`})," ejes cartesianos de ",e.jsx(a,{children:n`\mathbb{R}^{n}`}),". La derivada direccional permite derivar ",e.jsx(a,{children:n`f`})," con respecto a cualquier dirección posible en ",e.jsx(a,{children:n`\mathbb{R}^{n}`}),"."]}),e.jsxs(i,{concept:"Derivada direccional",children:["Sea ",e.jsx(a,{children:n`f\colon U\subseteq \mathbb{R}^{n}\to \mathbb{R}`})," una función escalar de ",e.jsx(a,{children:n`n`})," variables que es diferenciable en ",e.jsx(a,{children:n`\bvec{x}`})," y sea ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{n} \mid \bvec{v}\neq \bvec{0}`})," un vector, la ",e.jsx("em",{children:"derivada direccional"})," de ",e.jsx(a,{children:n`f`})," en la dirección de ",e.jsx(a,{children:n`\bvec{v}`})," en el punto ",e.jsx(a,{children:n`\bvec{x}`}),", denotada por ",e.jsx(a,{children:n`\mathrm{D}_{\bvec{v}} f`}),", está definida por",e.jsx(a,{block:!0,children:n`\mathrm{D}_{\bvec{v}} f = \lim_{h\to 0} \frac{f(\bvec{x}+h\uvec{v})-f(\bvec{x})}{h}`}),"donde ",e.jsx(a,{children:n`\uvec{v}`})," es el vector unitario de ",e.jsx(a,{children:n`\bvec{v}`}),", ",e.jsx(a,{children:n`\uvec{v} = \bvec{v}/\norm{\bvec{v}}`}),"."]}),e.jsxs("p",{children:["En la definición, se elige el vector unitario ",e.jsx(a,{children:n`\uvec{v}`})," en lugar del vector ",e.jsx(a,{children:n`\bvec{v}`})," porque de dicho vector únicamente interesa su dirección."]}),e.jsxs("p",{children:["A causa de la definición anterior, la derivada direccional de de ",e.jsx(a,{children:n`f`})," en la dirección de ",e.jsx(a,{children:n`\bvec{v}`})," en el punto ",e.jsx(a,{children:n`\bvec{x}`})," se puede escribir como",e.jsx(a,{block:!0,children:n`\mathrm{D}_{\bvec{v}} f =\der{}{t} f(\bvec{x}+t\bvec{v}) \mid_{t=0}`}),"donde ",e.jsx(a,{children:n`\bvec{x}+t\bvec{v}`})," es la ecuación vectorial de una recta ",e.jsx(a,{children:n`\ell`}),". Si el punto es ",e.jsx(a,{children:n`\bvec{x}=(a,b,c)`}),", se tiene",e.jsx(a,{block:!0,children:n`
	\ell \coloneqq \begin{pmatrix}
	x\\y\\z
	\end{pmatrix} = (a,b,c) + \bvec{v}t.
`}),"Sumado a lo anterior, se puede usar la gradiente para facilitar el cálculo de la derivada direccional, como se enuncia en el siguiente teorema."]}),e.jsxs(o,{children:["Sea ",e.jsx(a,{children:n`f`})," una función diferenciable, su derivada direccional en la dirección de ",e.jsx(a,{children:n`\bvec{v}`})," en el punto ",e.jsx(a,{children:n`\bvec{x}`})," se puede calcular como",e.jsx(a,{block:!0,children:n`\mathrm{D}_{\bvec{v}} f =\nabla f(\bvec{x}) \cdot \uvec{v}`})]}),"La derivada parcial ",e.jsx(a,{children:n`\partial f /\partial x_i`})," indica cómo crece o decrece la función en la dirección ",e.jsx(a,{children:n`x_i`}),". La derivada direccional generaliza esa noción para cualquier dirección:  ",e.jsx(a,{children:n`\mathrm{D}_{\bvec{v}} f`})," indica cómo crece o decrece la función en la dirección ",e.jsx(a,{children:n`\uvec{v}`}),", dando su tasa de cambio. Al evaluar la derivada direccional en la dirección ",e.jsx(a,{children:n`\uvec{v}`})," en un punto ",e.jsx(a,{children:n`\bvec{u}`}),", se obtiene la tasa de crecimiento o decrecimiento en ese punto en esa dirección. Entre más positiva es ",e.jsx(a,{children:n`\mathrm{D}_{\bvec{v}} f(\bvec{u})`}),", mayor es la tasa o rapidez en la que crece la función en el punto ",e.jsx(a,{children:n`\bvec{u}`})," en la dirección ",e.jsx(a,{children:n`\uvec{v}`})," y entre más negativa es ",e.jsx(a,{children:n`\mathrm{D}_{\bvec{v}} f(\bvec{u})`}),", mayor es la rapidez en la que la función decrece en ",e.jsx(a,{children:n`\bvec{u}`})," hacia la dirección ",e.jsx(a,{children:n`\uvec{v}`}),".",e.jsxs(r,{title:"Derivada direccional",children:["Sean ",e.jsx(a,{children:n`f\colon \mathbb{R}^{3}\to\mathbb{R}`})," dada por ",e.jsx(a,{children:n`f(x,y,z)=3x+y^2+4\cos(z)`}),", ",e.jsx(a,{children:n`\bvec{u}=(2,3,\uppi/2)`})," y  ",e.jsx(a,{children:n`\uvec{v}=(-1/\sqrt{2},1/\sqrt{2},0)`}),", halle la derivada direccional de ",e.jsx(a,{children:n`f(\bvec{u})`})," en la dirección ",e.jsx(a,{children:n`\uvec{v}`}),"."]}),e.jsx("h4",{children:"Direcciones de máximo crecimiento y decrecimiento"}),e.jsxs("p",{children:["Haciendo uso de las propiedades del producto punto, la operación ",e.jsx(a,{children:n`\nabla f(\bvec{x})\cdot\uvec{v}`})," que da la derivada direccional de ",e.jsx(a,{children:n`f`})," en la dirección de ",e.jsx(a,{children:n`\bvec{v}`})," en el punto ",e.jsx(a,{children:n`\bvec{x}`}),", se puede reescribir como","El análisis de la  arroja un teorema útil.La derivada direccional es máxima cuando el coseno del ángulo entre los vectores es máximo, que es cuando su valor es ",e.jsx(a,{children:n`1`})," (recuérdese que para todo ",e.jsx(a,{children:n`x`}),", ",e.jsx(a,{children:n`-1\leq \cos(x)\leq 1`}),"). Eso ocurre cuando los vectores son paralelos, pues ",e.jsx(a,{children:n`\cos(0)=\cos(2\uppi)=1`}),".En otras palabras, la derivada direccional ",e.jsx(a,{children:n`\mathrm{D}_{\bvec{v}}f`})," es máxima cuando ",e.jsx(a,{children:n`\bvec{v}`})," es y ",e.jsx(a,{children:n`\nabla f`})," tienen la misma dirección.Ergo, el gradiente ",e.jsx(a,{children:n`\nabla f`})," apunta en la dirección en la cuál la derivada direccional de una función es máxima, que es la dirección de máximo crecimiento de ",e.jsx(a,{children:n`f`}),"."]}),e.jsxs(o,{children:["Sea ",e.jsx(a,{children:n`f\colon U\subseteq\mathbb{R}^{n}\to\mathbb{R}`})," una función diferenciable, el vector ",e.jsx(a,{children:n`\nabla f`})," apunta en la dirección a lo largo de la cual ",e.jsx(a,{children:n`f`})," crece más rápidamente.El vector ",e.jsx(a,{children:n`- \nabla f`})," apunta en la dirección a lo largo de la cual ",e.jsx(a,{children:n`f`})," decrece más rápidamente."]}),e.jsxs("p",{children:["Usualmente se quiere hallar la dirección de máximo crecimiento o decrecimiento de una función ",e.jsx(a,{children:n`f`})," desde un punto ",e.jsx(a,{children:n`\bvec{v}`}),".En ese caso, se evalúa la gradiente para obtener que la dirección de máximo crecimiento de ",e.jsx(a,{children:n`f`})," en ",e.jsx(a,{children:n`\bvec{v}`})," está dada por la dirección de ",e.jsx(a,{children:n`\nabla f (\bvec{v})`}),".Dicha dirección es el vector unitario","El valor negativo de ese vector unitario es la dirección de mayor decrecimiento de ",e.jsx(a,{children:n`f`})," en el punto ",e.jsx(a,{children:n`\bvec{v}`}),".La norma del gradiente es igual al valor de la derivada direccional máxima."]}),e.jsx("h5",{children:"Puntos estacionarios"}),e.jsxs("p",{children:["También se puede analizar la  para el caso en el que la derivada direccional es nula, es decir, para el caso en el que no hay crecimiento ni decrecimiento en el punto en el que se evalúa.La derivada direccional es nula cuando el coseno del ángulo de los vectores es ",e.jsx(a,{children:n`0`}),", o sea cuando ",e.jsx(a,{children:n`\bvec{v}`})," es perpendicular a ",e.jsx(a,{children:n`\nabla f`}),".Eso implica el siguiente teorema."]}),e.jsxs(o,{children:["Sea ",e.jsx(a,{children:n`f\colon U\subseteq\mathbb{R}^{n}\to\mathbb{R}`})," una función diferenciable, el vector ",e.jsx(a,{children:n`\nabla f(\bvec{v})`})," es igual al vector nulo ",e.jsx(a,{children:n`\bvec{0}`})," si y solamente si ",e.jsx(a,{children:n`\bvec{v}`})," es un punto estacionario."]}),e.jsxs(i,{concept:"Punto estacionario",children:["Un ",e.jsx("em",{children:"punto estacionario"})," es un punto en el que una función no presenta crecimiento ni decrecimiento. Todo punto estacionario es o bien un extremo relativo (máximo o mínimo local) o bien un punto de silla."]}),e.jsx("h3",{children:"Diferenciabilidad de funciones escalares"}),e.jsx("h4",{children:"Diferenciabilidad de funciones escalares de dos variables"}),e.jsxs("p",{children:["Sea ",e.jsx(a,{children:n`f\colon U\subseteq \mathbb{R}^{2}\to\mathbb{R}`})," una función escalar de dos variables y sea ",e.jsx(a,{children:n`(a,b)\in A`})," un punto. Se dice que ",e.jsx(a,{children:n`f`})," es ",e.jsx("em",{children:" diferenciable"})," en ",e.jsx(a,{children:n`(a,b)`})," si y solamente si"]}),e.jsxs("ul",{children:[e.jsxs("li",{children:["[i.] ",e.jsx(a,{children:n`\dparder{f}{x}`})," y ",e.jsx(a,{children:n`\dparder{f}{y}`})," existen en ",e.jsx(a,{children:n`(a,b)`}),"."]}),e.jsxs("li",{children:["[ii.] ",e.jsx(a,{children:n`\displaystyle \lim_{(x,y)\to(a,b)} \cfrac{f(x,y)- \left[f(a,b)+\left(\dparder{f(a,b)}{x}\right)(x-a)+\left(\dparder{f(a,b)}{y}\right)(y-b)\right]}{\norm{(x,y)-(a,b)}} = 0`}),"."]})]}),e.jsxs("p",{children:["En el ítem ii, el término que está entre corchetes es la mejor aproximación lineal a la función ",e.jsx(a,{children:n`f`})," cerca del punto ",e.jsx(a,{children:n`(a,b)`}),".A causa de eso, la ecuación del plano en ",e.jsx(a,{children:n`\mathbb{R}^{3}`})," que es tangente a la superficie ",e.jsx(a,{children:n`f`})," en el punto ",e.jsx(a,{children:n`(a,b)`})," está dada por ese término igualado a ",e.jsx(a,{children:n`z`}),":"]}),e.jsx("h4",{children:"Diferenciabilidad continua"}),e.jsxs("p",{children:["De forma análoga a las funciones escalares de una variable, la diferenciabilidad continua de una función consiste en que la función sea diferenciable y todas sus derivadas parciales sean continuas y diferenciables. Sea ",e.jsx(a,{children:n`f`})," una función, si lo anterior sucede para las derivadas parciales de primer orden de ",e.jsx(a,{children:n`f`}),", ",e.jsx(a,{children:n`f`})," es ",e.jsx("em",{children:"una vez continuamente diferenciable"})," y de clase ",e.jsx(a,{children:n`C ^ 1`}),". Si ese es el caso para las derivadas parciales de enésimo orden de ",e.jsx(a,{children:n`f`}),", ",e.jsx(a,{children:n`f`})," es ",e.jsx("em",{children:"ene veces continuamente diferenciable"})," y de clase ",e.jsx(a,{children:n`C ^ n`}),". Si una función es de clase ",e.jsx(a,{children:n`C ^ n`})," para un ",e.jsx(a,{children:n`n \in \mathbb{N} \setminus \{0\} `})," arbitrariamente grande, entonces la función es ",e.jsx("em",{children:"infinitamente diferenciable"})," y se cataloga como de clase ",e.jsx(a,{children:n`C ^\infty`}),"."]})]}),e.jsxs(l,{title:"Optimización de funciones escalares de múltiples variables",children:[e.jsx("h3",{children:"Extremos de funciones escalares de múltiples variables"}),e.jsxs(i,{concept:"Mínimo local",children:["Sea ",e.jsx(a,{children:n`f\subseteq \mathbb{R}^{n}\colon U\to\mathbb{R}`})," una función escalar de ene variables, ",e.jsx(a,{children:n`f`})," tiene un ",e.jsx("em",{children:"mínimo local"})," en el punto ",e.jsx(a,{children:n`\bvec{v}`})," si existe un entorno en el que la imagen de ",e.jsx(a,{children:n`\bvec{v}`})," es menor a cualquier otra imagen.",e.jsx(a,{block:!0,children:n`
	\text{Existe }\varepsilon >0\text{ tal que para todo }\bvec{x} \in B_\varepsilon(\bvec{v})\text{ se satisface } f(\bvec{v}) \leq f(\bvec{x}).
`}),"En ese caso, ",e.jsx(a,{children:n`\bvec{v}, f(\bvec{v})`})," es el ",e.jsx("em",{children:"punto mínimo local"})," y ",e.jsx(a,{children:n`f(\bvec{v})`})," es el ",e.jsx("em",{children:"valor mínimo"})," de ",e.jsx(a,{children:n`f`})," en ",e.jsx(a,{children:n`B_\varepsilon(\bvec{v})`}),"."]}),e.jsxs(i,{concept:"Máximo local",children:["Sea ",e.jsx(a,{children:n`f\subseteq \mathbb{R}^{n}\colon U\to\mathbb{R}`})," una función escalar de ene variables, ",e.jsx(a,{children:n`f`})," tiene un ",e.jsx("em",{children:"máximo local"})," en el punto ",e.jsx(a,{children:n`\bvec{v}`})," si existe un entorno en el que la imagen de ",e.jsx(a,{children:n`\bvec{v}`})," es mayor a cualquier otra imagen.",e.jsx(a,{block:!0,children:n`
	\text{Existe }\varepsilon >0\text{ tal que para todo }\bvec{x} \in B_\varepsilon(\bvec{v})\text{ se satisface }  f(\bvec{v}) \geq f(\bvec{x}).
`}),"En ese caso, ",e.jsx(a,{children:n`\bvec{v}, f(\bvec{v})`})," es el ",e.jsx("em",{children:"punto máximo local"})," y ",e.jsx(a,{children:n`f(\bvec{v})`})," es el ",e.jsx("em",{children:"valor máximo"})," de ",e.jsx(a,{children:n`f`})," en ",e.jsx(a,{children:n`B_\varepsilon(\bvec{v})`}),"."]}),e.jsx("h4",{children:"Puntos críticos"}),e.jsxs("p",{children:["Si existe un extremo local en ",e.jsx(a,{children:n`\bvec{v}`}),", entonces ",e.jsx(a,{children:n`\bvec{v}`})," es un vector crítico. La conversa no siempre se cumple."]}),e.jsxs(i,{concept:"Punto crítico de funciones escalares",children:["El punto ",e.jsx(a,{children:n`(\bvec{v}, f(\bvec{v}))`})," es un ",e.jsx("em",{children:"punto crítico"})," de una función escalar ",e.jsx(a,{children:n`f`})," si ",e.jsx(a,{children:n`\nabla f(\bvec{v}) = \bvec{0}`}),". En ese caso, ",e.jsx(a,{children:n`\bvec{v}`})," es un ",e.jsx("em",{children:"vector crítico"}),"."]}),e.jsxs("p",{children:["Para hallar los puntos críticos se resuelve la ecuación",e.jsx(a,{block:!0,children:n`\nabla f(\bvec{x}) = \bvec{0}`}),"que implica igualar cada componente del vector gradiente a cero. Eso es equivalente a resolver el siguiente sistema de ene ecuaciones con ene variables:",e.jsx(a,{block:!0,children:n`
	\begin{cases}
		\dparder{f}{x_1} = 0 \\[1em] \dparder{f}{x_2} = 0\\[1em]
		\qquad \vdots \\[0.5em]
		\dparder{f}{x_n} = 0
	\end{cases}
`})]}),e.jsxs("p",{children:["El sistema puede no tener solución, tener una solución o tener múltiples soluciones. Si existen soluciones, serán de la forma ",e.jsx(a,{children:n`\bvec{v} = (v_1,v_2,\ldots,v_n)`})," y cada solución será un punto crítico."]}),e.jsxs("p",{children:["Si ",e.jsx(a,{children:n`\bvec{v}`})," es un punto crítico, entonces puede que sea un punto estacionario, por lo que si ",e.jsx(a,{children:n`\bvec{v}`})," no es un punto crítico degenerado, ",e.jsx(a,{children:n`f(\bvec{v})`})," es o bien un extremo o bien un punto de silla."]}),e.jsx("h3",{children:"Hessiano y criterios para puntos críticos"}),e.jsx("h4",{children:"Polinomio de Taylor de segundo grado para funciones escalares de múltiples variables"}),e.jsxs("p",{children:["Sea ",e.jsx(a,{children:n`f(x)`})," una función escalar de una variable de clase ",e.jsx(a,{children:n`C^n`}),", se sabe que su serie de Taylor está dada por la siguiente serie infinita",e.jsx(a,{block:!0,children:n`f(x) = \sum_{n=0}^{\infty} \frac{f^{(n)}(c)}{n!}(x-c)^n`}),"Por ello, el polinomio de Taylor de enésimo grado centrado en el punto ",e.jsx(a,{children:n`c`})," está dado por",e.jsx(a,{block:!0,children:n`
	P_n(x) = f(c)+f'(c)(x-c)+\frac{f''(c)}{2}(x-c)^2+\frac{f'''(c)}{3!}(x-c)^3+\cdots+\frac{f^{(n)}(c)}{n!}(x-c)^n.
`}),"Para toda función escalar ",e.jsx(a,{children:n`f`}),", el polinomio de Taylor de primer grado es la mejor aproximación lineal de la función alrededor de un punto. El polinomio de Taylor segundo grado es la mejor aproximación cuadrática de la función ",e.jsx(a,{children:n`f`})," alrededor del punto ",e.jsx(a,{children:n`c,f(c)`}),",",e.jsx(a,{block:!0,children:n`P_2(x) = f(c)+f'(c)(x-c)+\frac{f''(c)}{2}(x-c)^2.`}),"En particular, si la función tiene un máximo o mínimo local en un ",e.jsx(a,{children:n`c`}),", el polinomio de Taylor de segundo grado también tendrá un máximo o mínimo en ",e.jsx(a,{children:n`c`}),", acorde. Por ello, cuando la primera derivada de la función evaluada en ",e.jsx(a,{children:n`c`})," es cero, la segunda derivada da un criterio para saber que tipo de extremo es el punto crítico."]}),e.jsxs("p",{children:["Análogamente, sea ",e.jsx(a,{children:n`f\colon U\subseteq \mathbb{R}^{n} \to \mathbb{R}`})," una función escalar de ene variables de clase ",e.jsx(a,{children:n`C^3`}),". El polinomio de Taylor de primer grado centrado en el vector ",e.jsx(a,{children:n`\bvec{v}`})," es",e.jsx(a,{block:!0,children:n`\begin{align*}
	P_1(\bvec{x}) &= f(\bvec{v})+\sum_{i=1}^{n} \frac{\partial f(\bvec{v})}{\partial x_i}(x_i-v_i) \\
	P_1(\bvec{x}) &= f(\bvec{v})+(\mathrm{D}f(\bvec{v}))(\bvec{x}-\bvec{v}) \\
\end{align*}`}),"El polinomio de Taylor de segundo grado centrado en el vector ",e.jsx(a,{children:n`\bvec{v}`})," es",e.jsx(a,{block:!0,children:n`\begin{align*}
	P_2(\bvec{x}) &= f(\bvec{v})+\sum_{i=1}^{n} \frac{\partial f(\bvec{v})}{\partial x_i} (x_i-v_i) + \frac{1}{2}\sum_{i,j=1}^{n} \frac{\partial ^2 f(\bvec{v})}{\partial x_i \partial x_j} (x_i-v_i)(x_j-v_j) \\
	P_2(\bvec{x}) &= (\nabla f(\bvec{v})) \cdot (x_1-v_1, x_2-v_2, \ldots, x_n-v_n) \\
	P_2(\bvec{x}) &= (\nabla f(\bvec{v})) \cdot (\bvec{x}-\bvec{v})
\end{align*}`}),"Nótese que, aunque se sabe que ",e.jsx(a,{children:n`\partial^2 f /\partial x_j \partial x_i = \partial^2 f /\partial x_i \partial x_j`}),", esa segunda derivada debe sumarse dos veces en la sumatoria del tercer término del polinomio de Taylor de segundo grado."]}),e.jsxs("p",{children:["Como dicho arriba, si la función tiene un máximo o mínimo local en un ",e.jsx(a,{children:n`\bvec{v}`}),", el polinomio de Taylor de segundo grado también tendrá un máximo o mínimo en ",e.jsx(a,{children:n`\bvec{v}`}),", acorde. Dicho eso, a partir del polinomio de Taylor de segundo grado se puede establecer un criterio para identificar en qué puntos hay máximos y mínimos en una función escalar de múltiples variables."]}),e.jsxs("p",{children:["El polinomio de Taylor de segundo grado centrado en el vector ",e.jsx(a,{children:n`\bvec{v}`})," se puede reescribir haciendo uso de la matriz hessiana, para que en lugar de sumatorias sus términos sean productos matriciales:",e.jsx(a,{block:!0,children:n`\begin{align*}
	P_2(\bvec{x}) &= f(\bvec{v})+(\mathrm{D}f(\bvec{v}))(\bvec{x}-\bvec{v}) + \frac{1}{2} \transpose{(\bvec{x}-\bvec{v})}[\mathrm{D}(\mathrm{D}f(\bvec{v}))](\bvec{x}-\bvec{v})\\
	P_2(\bvec{x}) &= f(\bvec{v})+(\mathrm{D}f(\bvec{v}))(\bvec{x}-\bvec{v}) + \frac{1}{2} \transpose{(\bvec{x}-\bvec{v})}[H(f(\bvec{v}))](\bvec{x}-\bvec{v}).
\end{align*}`})]}),e.jsx("h4",{children:"Hessiano"}),e.jsxs(i,{concept:"Matriz hessiana",children:["Sea ",e.jsx(a,{children:n`U\subseteq \mathbb{R}^{n}`})," un conjunto abierto y ",e.jsx(a,{children:n`f\colon U \to \mathbb{R}`})," una función escalar de ene variables de clase ",e.jsx(a,{children:n`C^2`}),". La ",e.jsx("em",{children:"matriz hessiana"})," de ",e.jsx(a,{children:n`f`})," es la matriz cuadrada de tamaño ",e.jsx(a,{children:n` n\times n `})," de sus segundas derivadas parciales.",e.jsx(a,{block:!0,children:n`\begin{align*}
		(H(f))_{ij} &= \dfrac{\partial^2 f}{\partial x_i \partial x_j}. \\
		H(f) &= \begin{pmatrix}
			\dfrac{\partial^2 f}{\partial x_1^2} & \dfrac{\partial ^2 f}{\partial x_1 \partial x_2} & \cdots& \dfrac{\partial^2 f}{\partial x_1 \partial x_n} \\[1em]
			\dfrac{\partial^2 f}{\partial x_2 \partial x_1} & \dfrac{\partial^2 f}{\partial x_2^2} & \cdots& \dfrac{\partial^2 f}{\partial x_2 \partial x_n} \\[1em]
			\vdots & \vdots & \ddots & \vdots \\[0.5em]
			\dfrac{\partial^2 f}{\partial x_n \partial x_1} & \dfrac{\partial^2 f}{\partial x_n \partial x_2} & \cdots&\dfrac{\partial^2 f}{\partial x_n^2} \\[1em]
		\end{pmatrix}
	\end{align*}`}),"Por la propiedad de simetría de la derivada parcial, la matriz hessiana es una matriz simétrica. Esa proposición se conoce como el teorema de Clairaut o teorema de Schwarz."]}),e.jsx("p",{children:"El Hessiano de una función escalar se define como el tercer término de su polinomio de Taylor de grado dos."}),e.jsxs(i,{concept:"Hessiano",children:["Sea ",e.jsx(a,{children:n`U\subseteq \mathbb{R}^{n}`})," un conjunto abierto y ",e.jsx(a,{children:n`f\colon U \to \mathbb{R}`})," una función escalar de ene variables de clase ",e.jsx(a,{children:n`C^2`}),". El ",e.jsx("em",{children:"hessiano"})," de ",e.jsx(a,{children:n`f`})," en el punto ",e.jsx(a,{children:n`\bvec{v}`})," es la función escalar de múltiples variables ",e.jsx(a,{children:n`Hf(\bvec{v})`})," dada por",e.jsx(a,{block:!0,children:n`
		(Hf(\bvec{v}))(\bvec{x}) = \frac{1}{2} \sum_{i,j=1}^{n} \frac{\partial ^2 f(\bvec{v})}{\partial x_i \partial x_j} (x_i-v_i)(x_j-v_j).
	`})]}),e.jsxs("p",{children:["El Hessiano es nulo, ",e.jsx(a,{children:n`H(\bvec{x})=0`}),", si y solamente si ",e.jsx(a,{children:n`\bvec{v}=\bvec{x}`}),". Mientras el Hessiano no sea nulo:"]}),e.jsxs("ul",{children:[e.jsxs("li",{children:[" La función ",e.jsx(a,{children:n`H`})," es ",e.jsx("em",{children:"definitivamente positiva"})," si ",e.jsx(a,{children:n`H(\bvec{x}) \geq 0`})," para todo ",e.jsx(a,{children:n`\bvec{x}`}),". Si ",e.jsx(a,{children:n`H`})," es definitivamente positiva, entonces ",e.jsx(a,{children:n`\bvec{v}`})," es un mínimo local."]}),e.jsxs("li",{children:[" La función ",e.jsx(a,{children:n`H`})," es ",e.jsx("em",{children:"definitivamente negativa"})," si ",e.jsx(a,{children:n`H(\bvec{x}) \leq 0`})," para todo ",e.jsx(a,{children:n`\bvec{x}`}),". Si ",e.jsx(a,{children:n`H`})," es definitivamente positiva, entonces ",e.jsx(a,{children:n`\bvec{v}`})," es un máximo local local."]})]}),e.jsx("p",{children:"El Hessiano es una función cuadrática. Por ende, las variables suelen estar a la segunda potencia y eso facilita identificar si el Hessiano será siempre positivo o siempre negativo. Sin embargo, el Hessiano no siempre tiene un signo fijo."}),e.jsx(s,{children:"Que el Hessiano de una función escalar de múltiples variables sea definitivamente positiva es análogo a que una función escalar de una variable sea cóncava hacia arriba."}),e.jsx("h4",{children:"Hessiano para funciones escalares de dos variables"}),e.jsxs("p",{children:["Sea ",e.jsx(a,{children:n`U \in\mathbb{R}^{2}`})," un conjunto abierto y sea ",e.jsx(a,{children:n`f\colon U \to \mathbb{R}`})," una función escalar de dos variables de clase ",e.jsx(a,{children:n`C^3`}),". Si ",e.jsx(a,{children:n`\nabla f(\bvec{v})=\bvec{0}`}),", de forma que ",e.jsx(a,{children:n`\bvec{v}`})," es un punto crítico, se cumple que",e.jsx(a,{block:!0,children:n`\begin{gather}
	\parder{f(\bvec{v})}{x} = \parder{f(\bvec{v})}{y} = 0.
\end{gather}`})]}),e.jsxs(c,{children:["Se debe revisar si los puntos críticos hallados se encuentran en el dominio de ",e.jsx(a,{children:n`f`}),". Si ",e.jsx(a,{children:n`\bvec{v}\in U`}),", ",e.jsx(a,{children:n`\bvec{v}`})," es un posible candidato para extremo o punto de silla; de lo contrario, ",e.jsx(a,{children:n`\bvec{v}`})," se descarta. Si ",e.jsx(a,{children:n`\bvec{v}`})," está en la frontera de ",e.jsx(a,{children:n`U`}),", es un posible candidato para extremo o punto de silla pero ",e.jsx("i",{children:"no"})," se puede usar el criterio dado por el determinante de la matriz de segundas derivadas."]}),e.jsxs("p",{children:["Se puede saber si el punto crítico ",e.jsx(a,{children:n`\bvec{v}\in U`})," es un extremo o punto de silla haciendo uso del determinante de la matriz hessiana, dado por",e.jsx(a,{block:!0,children:n`
	\begin{vmatrix}
		\dnparder{2}{f}{x} & \dfrac{\partial^2 f}{\partial x \partial y} \\[2ex]
		\dfrac{\partial^2 f}{\partial y \partial x} & \dnparder{2}{f}{y}
	\end{vmatrix} = \left(\nparder{2}{f}{x}\right)\left(\nparder{2}{f}{y}\right) - \left(\frac{\partial^2 f}{\partial x \partial y}\right)^2.
`}),"El determinante de la matriz hessiana da origen al siguiente criterio:"]}),e.jsxs("ul",{children:[e.jsxs("li",{children:[" Si ",e.jsx(a,{children:n`\displaystyle \left(\nparder{2}{f(\bvec{v})}{x}\right)\left(\nparder{2}{f(\bvec{v})}{y}\right) - \left(\frac{\partial^2 f(\bvec{v})}{\partial x \partial y}\right)^2 >0 `}),", existe un extremo en ",e.jsx(a,{children:n`f(\bvec{v})`}),"."]}),e.jsxs("ul",{children:[e.jsxs("li",{children:[" Si ",e.jsx(a,{children:n`\displaystyle \nparder{2}{f(\bvec{v})}{x} >0 `}),", entonces ",e.jsx(a,{children:n`f(\bvec{v})`})," es un mínimo."]}),e.jsxs("li",{children:[" Si ",e.jsx(a,{children:n`\displaystyle \nparder{2}{f(\bvec{v})}{x} <0 `}),", entonces ",e.jsx(a,{children:n`f(\bvec{v})`})," es un máximo. "]})]}),e.jsxs("li",{children:["  Si ",e.jsx(a,{children:n`\displaystyle \left(\nparder{2}{f(\bvec{v})}{x}\right)\left(\nparder{2}{f(\bvec{v})}{y}\right) - \left(\frac{\partial^2 f(\bvec{v})}{\partial x \partial y}\right)^2 <0 `}),", hay un punto de silla ",e.jsx(a,{children:n`f(\bvec{v})`}),"."]}),e.jsxs("li",{children:["  Si ",e.jsx(a,{children:n`\displaystyle \left(\nparder{2}{f(\bvec{v})}{x}\right)\left(\nparder{2}{f(\bvec{v})}{y}\right) - \left(\frac{\partial^2 f(\bvec{v})}{\partial x \partial y}\right)^2 = 0 `}),", es un ",e.jsx("em",{children:"punto crítico degenerado"}),", por lo que no se puede afirmar nada sobre el comportamiento de la función en ese punto."]})]}),e.jsx(s,{children:"En las funciones escalares de una variable, los puntos de silla se ven como puntos de inflexión."}),e.jsx("h3",{children:"Hallar extremos locales de funciones escalares de múltiples variables restringidas a un compacto"}),e.jsx("p",{children:"Si se analiza únicamente el dominio de la función que está interseca con un compacto, siempre es posible hallar extremos locales para la función en los puntos analizados."}),e.jsxs(o,{name:"Existencia de extremos en un compacto",children:["Sea ",e.jsx(a,{children:n`C \subseteq\mathbb{R}^{n}`})," un compacto y sea ",e.jsx(a,{children:n`f \colon C \to \mathbb{R}`})," una función escalar continua, entonces existen dos puntos ",e.jsx(a,{children:n`\bvec{u},\bvec{v} \in C`})," tal que",e.jsxs("ul",{children:[e.jsxs("li",{children:[" [i.] Para todo ",e.jsx(a,{children:n`\bvec{x}\in C`}),", ",e.jsx(a,{children:n`f(\bvec{u})\leq f(\bvec{x})`}),"."]}),e.jsxs("li",{children:[" [ii.] Para todo ",e.jsx(a,{children:n`\bvec{x}\in C`}),", ",e.jsx(a,{children:n`f(f(\bvec{v})\geq\bvec{x}) `}),"."]})]}),"En otras palabras, ",e.jsx(a,{children:n`f|_C`})," tiene un mínimo local en algún ",e.jsx(a,{children:n`\bvec{u}`})," y un máximo local en algún ",e.jsx(a,{children:n`\bvec{v}`}),"."]}),e.jsxs("p",{children:["Sea ",e.jsx(a,{children:n`C\in \mathbb{R}^{n}`})," un compacto, existen dos métodos  para hallar los extremos locales de una función restringida al compacto."]}),e.jsx("h4",{children:"Método de parametrización"}),e.jsxs("p",{children:["El ",e.jsx("em",{children:"método de parametrización"})," es útil para hallar los extremos locales de una función restringida a un  compacto si el compacto está descrito por más de una ecuación, como la región encerrada por las ecuaciones. Es decir, se quieren hallar los extremos de una función escalar ",e.jsx(a,{children:n`f`})," restringida a las curvas ",e.jsx(a,{children:n`y=g_1(x), y=g_2(x), \ldots y=g_n(x)`}),", que describen el compacto ",e.jsx(a,{children:n`C`})," y en conjunto se denotan ",e.jsx(a,{children:n`y=g_i(x)`}),"."]}),e.jsxs("ol",{children:[e.jsxs("li",{children:[" Hallar los puntos críticos de ",e.jsx(a,{children:n`f`})," y tomar únicamente los vectores críticos ",e.jsx(a,{children:n`\bvec{v}_i`})," que pertenezcan al compacto ",e.jsx(a,{children:n`C`}),". Evaluar dichos vectores críticos en ",e.jsx(a,{children:n`f`})," para obtener valores que candidatos a ser extremos locales."]}),e.jsxs("li",{children:[" Dibujar la región que describe el compacto en ",e.jsx(a,{children:n` \mathbb{R}^{2} `}),", graficando las curvas ",e.jsx(a,{children:n`y=g_i(x)`})," e identificando la región que estas encierran."]}),e.jsxs("li",{children:[" Hallar los puntos de intersección de las ecuaciones que describen el compacto. Si ",e.jsx(a,{children:n`C`})," es descrito por dos ecuaciones de la forma ",e.jsx(a,{children:n`y=g_1(x)`})," y ",e.jsx(a,{children:n` y=g_2(x) `}),", la coordenada o coordenadas en ",e.jsx(a,{children:n`x`})," donde intersecan las ecuaciones está dada por la ecuación"]}),e.jsx(a,{block:!0,children:n`g_1(x) = g_2(x).`}),e.jsxs("li",{children:[" Realizar la parametrización de cada una de las ecuaciones que describen el compacto. Para parametrizar una curva de forma ",e.jsx(a,{children:n`y=g_i(x)`}),", se escribe"]}),e.jsx(a,{block:!0,children:n`\begin{gather*}
		x = t.\\
		y = g_i(t).
	\end{gather*}`}),"para todo ",e.jsx(a,{children:n`t \in [a,b]`}),". Los valores ",e.jsx(a,{children:n`a`})," y ",e.jsx(a,{children:n`b`})," que definen el intervalo que restringe al parámetro ",e.jsx(a,{children:n`t`})," está dado por las coordenadas en ",e.jsx(a,{children:n`x`})," de los puntos de intersección de las ecuaciones que describen el compacto.",e.jsxs("li",{children:[" Reemplazar las parametrizaciones en la función original ",e.jsx(a,{children:n`f(x,y)`}),", de forma que para cada curva ",e.jsx(a,{children:n`y=g_i(x)`})," se obtiene una expresión ",e.jsx(a,{children:n`f_i(t,g_i(t))`}),". "]}),e.jsxs("li",{children:[" Derivar cada una de las expresiones ",e.jsx(a,{children:n`f_i(t,g_i(t))`}),", que son funciones escalares de una variable, con respecto al parámetro ",e.jsx(a,{children:n`t`}),", usando métodos del cálculo diferencial."]}),e.jsxs("li",{children:[" Igualar cada una de las derivadas ",e.jsx(a,{children:n`f_i'(t,g_i(t))`})," a cero, "]}),e.jsx(a,{block:!0,children:n`\der{}{t}f_i(t,g_i(t)) = 0`}),"para hallar los números críticos de cada una, que tendrán la forma ",e.jsx(a,{children:n`t_i = c_i`}),".",e.jsxs("li",{children:[" Evaluar en cada expresión ",e.jsx(a,{children:n`f_i(t,g_i(t))`})," sus puntos críticos ",e.jsx(a,{children:n`c_i`})," y los extremos ",e.jsx(a,{children:n`a`})," y ",e.jsx(a,{children:n`b`})," que restringen al parámetro ",e.jsx(a,{children:n`t`}),". Los valores obtenidos al evaluar son candidatos a ser extremos locales."]}),e.jsxs("li",{children:[" Seleccionar el número más grande y el más pequeño entre todos los candidatos a ser extremos locales (aquellos obtenidos tras realizar las evaluaciones en las expresiones  ",e.jsx(a,{children:n`f_i(t,g_i(t))`})," y aquellos que se obtienen al evaluar los puntos críticos). Esos son el valor máximo y el valor mínimo, respectivamente, de ",e.jsx(a,{children:n`f`})," restringida a las curvas. "]})]}),e.jsxs(r,{title:"Extremos con parametrización",children:["Dada la función ",e.jsx(a,{children:n`f(x,y)=x^2+y^2-2y`})," definida en el disco ",e.jsx(a,{children:n`C \coloneqq x^2+y^2\leq 4`}),", hallar los extremos de la función en el disco.",e.jsx(a,{block:!0,children:n`\begin{gather*}
		\nabla f = (2x,2y-2) = (0,0).
		x=0 
		y=1
		(0,1) \in C
	\end{gather*}`}),"Se revisa el borde de ",e.jsx(a,{children:n`C`}),", es decir ",e.jsx(a,{children:n`x^2+y^2= 4`}),":",e.jsx(a,{block:!0,children:n`\begin{gather*}
			x=2\cos\theta
			y=2\sin\theta
		\end{gather*}`})]}),e.jsx("h4",{children:"Método del multiplicador de Lagrange"}),e.jsxs("p",{children:["El ",e.jsx("em",{children:"método del multiplicador de Lagrange"})," es eficiente para hallar los extremos locales de una función restringida a un compacto si el compacto está descrito una ecuación o desigualdad. El método se cimenta en el teorema del multiplicador de Lagrange."]}),e.jsxs(o,{name:"Teorema del multiplicador de Lagrange",children:["Sea ",e.jsx(a,{children:n`U`})," un conjunto abierto y sean ",e.jsx(a,{children:n`f,g\colon U\subseteq \mathbb{R}^{n} \to \mathbb{R}`})," funciones escalares de tipo ",e.jsx(a,{children:n`C^2`}),". Tome como hipótesis que para todo ",e.jsx(a,{children:n`\bvec{x} \in U`}),", ",e.jsx(a,{children:n`\nabla g(\bvec{x}) \neq 0`}),". Sea ",e.jsx(a,{children:n`S`})," el conjunto de nivel de ",e.jsx(a,{children:n`g`})," para el valor ",e.jsx(a,{children:n`c \in \mathbb{R}`}),", de forma que ",e.jsx(a,{block:!0,children:n`S=\{\bvec{x}\in U\mid g(\bvec{x})=c\},`})," se toma ",e.jsx(a,{children:n`S`})," como la frontera de un compacto. Si ",e.jsx(a,{children:n`f|_S`})," tiene un extremo en ",e.jsx(a,{children:n`\bvec{v}`}),", entonces existe un ",e.jsx("em",{children:"multiplicador de Lagrange"})," ",e.jsx(a,{children:n`\lambda \in \mathbb{R}`})," tal que",e.jsx(a,{block:!0,children:n`\nabla f (\bvec{v}) = \lambda \nabla g (\bvec{v}).`})]}),e.jsxs("p",{children:["Al hacer uso del multiplicador de Lagrange, se tienen dos funciones: ",e.jsx(a,{children:n`f\colon C\subseteq \mathbb{R}^{n} \to \mathbb{R}`})," es la función a optimizar y ",e.jsx(a,{children:n`g\colon C\subseteq \mathbb{R}^{n} \to \mathbb{R}`})," describe el compacto que restringe a la función, pues ",e.jsx(a,{children:n`g(\bvec{x})=c`})," es el borde del compacto ",e.jsx(a,{children:n`\partial C`})," y ",e.jsx(a,{children:n`g(\bvec{x})\leq c`})," es el compacto ",e.jsx(a,{children:n`C`})," en sí."]}),e.jsxs("ol",{children:[e.jsx("li",{children:" Verificar la hipótesis del teorema de Lagrange. Para ello, se debe comprobar que las soluciones a la ecuación"}),e.jsx(a,{block:!0,children:n`\nabla g(\bvec{x}) = 0`}),"no satisfagan ",e.jsx(a,{children:n` g(\bvec{x})=c `}),", de forma que no pertenezcan al borde del compacto.",e.jsxs("li",{children:[" Hallar los puntos críticos de ",e.jsx(a,{children:n`f`})," y tomar únicamente los puntos críticos ",e.jsx(a,{children:n`\bvec{v}_i`})," que satisfagan "]}),e.jsx(a,{block:!0,children:n`g(\bvec{v})\leq c`}),"y por ende pertenezcan al compacto.",e.jsx("li",{children:" Plantear el siguiente sistema de ecuaciones:"}),e.jsx(a,{block:!0,children:n`\begin{cases}
		\nabla f(\bvec{x}) = \lambda \nabla g (\bvec{x}) \\
		g(\bvec{x}) = c
	\end{cases}`}),"Que en el caso de funciones escalares de dos variables tendrá la forma",e.jsx(a,{block:!0,children:n`\begin{cases}
	\dparder{f}{f} = \lambda\dparder{g}{x} \\[1em]
	\dparder{f}{y} = \lambda\dparder{g}{y} \\[1em]
	g(\bvec{x}) = c
	\end{cases}`}),e.jsxs(s,{children:["El sistema de ecuaciones puede no ser lineal, por lo que no se puede depender de la reducción gaussiana o en Gauss-Jordan para su resolución. Es útil tomar dos casos para cada variable: o bien ",e.jsx(a,{children:n`x_i=0`}),", caso en el que ya se conoce una variable, o bien ",e.jsx(a,{children:n`x_i\neq 0`}),", caso en el que se puede dividir por ",e.jsx(a,{children:n`x_i`})," al despejar. Por ser mutuamente excluyentes, en alguno de los dos casos se llegará a una contradicción y el caso podrá descartarse."]}),e.jsxs("li",{children:["  Evaluar en ",e.jsx(a,{children:n`f`})," los valores hallados para ",e.jsx(a,{children:n`\bvec{x}`})," y los puntos críticos ",e.jsx(a,{children:n`\bvec{v}_i`}),". De los valores obtenidos al evaluar, que son los candidatos a ser extremos locales, se selecciona el mayor como máximo local y el menor como el mínimo local."]})]}),e.jsxs(r,{title:"Extremos con multiplicador de Lagrange",children:["Dada la función ",e.jsx(a,{children:n`f(x,y)=x^2+y^2-2y`})," definida en el disco ",e.jsx(a,{children:n`C \coloneqq x^2+y^2\leq 4`}),", hallar los extremos de la función en el disco."]})]}),e.jsxs(l,{title:"Cinemática",children:[e.jsxs(i,{concept:"Trayectoria",children:["Una ",e.jsx("em",{children:"trayectoria"})," en ",e.jsx(a,{children:n`\mathbb{R}^{n}`})," es una función vectorial de una variable ",e.jsx(a,{children:n`\sigma\colon [a,b]\subseteq \mathbb{R} \to \mathbb{R}^{n}`}),", dada por",e.jsx(a,{block:!0,children:n`\sigma (t) = (x_1(t),x_2(t),\ldots,x_n(t)).`}),"El ",e.jsx("em",{children:"punto inicial"})," de la trayectoria es ",e.jsx(a,{children:n`\sigma (a)`})," y ",e.jsx(a,{children:n`\sigma(b)`})," es el ",e.jsx("em",{children:"punto final"}),"."]}),e.jsxs("p",{children:["Si ",e.jsx(a,{children:n`\sigma`})," es diferenciable en ",e.jsx(a,{children:n`[a,b]`}),", entonces la trayectoria es diferenciable. En general, si ",e.jsx(a,{children:n`\sigma`})," es de clase ",e.jsx(a,{children:n`C^n`}),", la trayectoria es ",e.jsx(a,{children:n`n`})," veces continuamente diferenciable. Al modelar situaciones reales, la trayectoria es una función del tiempo con codominio en ",e.jsx(a,{children:n`\mathbb{R}^{2}`})," y ",e.jsx(a,{children:n`\mathbb{R}^{3}`}),".",e.jsx(a,{block:!0,children:n`\sigma (t) = (x(t), y(t), z(t)).`}),"Se deben parametrizar las funciones ",e.jsx(a,{children:n` x(t)`}),", ",e.jsx(a,{children:n` y(t)`})," y ",e.jsx(a,{children:n` z(t) `})," para obtener una expresión única para ",e.jsx(a,{children:n` \sigma (t) `}),".  La gráfica de la trayectoria es una curva en ",e.jsx(a,{children:n`\mathbb{R}^{2}`})," o ",e.jsx(a,{children:n`\mathbb{R}^{3}`})," que conecta los puntos inicial y final. Al graficar la trayectoria, es importante mostrar con flechas en la curva cuál es el sentido de la trayectoria para distinguir los puntos inicial y final."]}),e.jsxs(s,{children:["Para graficar una trayectoria, y en general una curva paramétrica, puede ser útil hacer una tabla de datos con columnas ",e.jsx(a,{children:n`t`}),", ",e.jsx(a,{children:n` x(t)`}),", ",e.jsx(a,{children:n` y(t)`})," y ",e.jsx(a,{children:n` z(t) `}),"."]}),e.jsxs(i,{concept:"Velocidad",children:["Sea ",e.jsx(a,{children:n`\sigma\colon [a,b]\subseteq \mathbb{R} \to \mathbb{R}^{n}`})," una trayectoria diferenciable en ",e.jsx(a,{children:n` \mathbb{R}^{n} `}),". La ",e.jsx("em",{children:"velocidad"}),", denotada por ",e.jsx(a,{children:n`\sigma'`}),", es la derivada de la trayectoria:",e.jsx(a,{block:!0,children:n`\sigma' (t) = (x_1'(t),x_2'(t),\ldots,x_n'(t)).`})]}),e.jsx("p",{children:"La velocidad es un vector, y es siempre tangente a la curva de la trayectoria."}),e.jsxs(i,{concept:"Rapidez",children:["Sea ",e.jsx(a,{children:n`\sigma\colon [a,b]\subseteq \mathbb{R} \to \mathbb{R}^{n}`})," una trayectoria diferenciable en ",e.jsx(a,{children:n` \mathbb{R}^{n} `}),", la ",e.jsx("em",{children:"rapidez"})," es la magnitud de la velocidad.",e.jsx(a,{block:!0,children:n`\norm{\sigma' (t)} = \sqrt{(x_1'(t))^2+(x_2'(t))^2+\cdots+(x_n'(t))^2}`})]}),e.jsxs(i,{concept:"Aceleración",children:["Sea ",e.jsx(a,{children:n`\sigma\colon [a,b]\subseteq \mathbb{R} \to \mathbb{R}^{n}`})," una trayectoria de clase ",e.jsx(a,{children:n`C^2`})," en ",e.jsx(a,{children:n` \mathbb{R}^{n} `}),". La ",e.jsx("em",{children:"aceleración"}),", denotada por ",e.jsx(a,{children:n`\sigma''`}),", es la derivada de la velocidad:",e.jsx(a,{block:!0,children:n`\sigma'' (t) = (x_1''(t),x_2''(t),\ldots,x_n''(t)).`})]}),e.jsxs(i,{concept:"Longitud de la trayectoria",children:["Sea ",e.jsx(a,{children:n`\sigma\colon [a,b]\subseteq \mathbb{R} \to \mathbb{R}^{n}`})," una trayectoria diferenciable en ",e.jsx(a,{children:n` \mathbb{R}^{n} `}),". La ",e.jsx("em",{children:"longitud de la trayectoria"}),", denotada por ",e.jsx(a,{children:n`L (\sigma)`}),", es la longitud de arco de la trayectoria, dada por",e.jsx(a,{block:!0,children:n`L (\sigma) = \defint{\norm{\sigma' (t)}}[t]{a}{b} \geq 0.`})]}),e.jsx("p",{children:"La longitud de la trayectoria siempre mayor o igual es a la distancia entre el punto inicial y el punto final. Solo es igual a dicha distancia si la trayectoria es una recta entre los dos puntos."}),e.jsxs(r,{children:["Sea ",e.jsx(a,{children:n`\sigma\colon [0,2] \to \mathbb{R}^{3}`})," la trayectoria dada por ",e.jsx(a,{children:n`\sigma (t) = (1,t,t^3/3)`}),".",e.jsxs("ol",{children:["[label=\\alph*]",e.jsx("li",{children:" Halle la velocidad y la rapidez."}),"La velocidad está dada por",e.jsx(a,{block:!0,children:n`\sigma' (t) = (0,1,t^2).`}),"La rapidez por",e.jsx(a,{block:!0,children:n`\norm{\sigma' (t)} = \sqrt{1+t^4}.`}),e.jsx("li",{children:" Halle la longitud de la trayectoria"}),"La longitud de la trayectoria está dada por"]})]})]}),e.jsxs(l,{title:"Derivación de funciones vectoriales",children:[e.jsxs("p",{children:["La derivada de una función vectorial ",e.jsx(a,{children:n`\bvec{F}`}),", denotada por ",e.jsx(a,{children:n`\mathrm{D}\bvec{F}`}),", está dada por el vector columna de gradientes de las funciones escalares que son sus componentes. Eso a su vez genera una matriz de derivadas parciales donde cada fila está asociada a una función y cada columna a una variable. Sea ",e.jsx(a,{children:n`\bvec{F}\colon U \subseteq \mathbb{R}^{n}\to \mathbb{R}^{m}`}),", de forma que",e.jsx(a,{block:!0,children:n`\bvec{F} = (F_1,F_2,\ldots,F_m)`}),"la derivada es una matriz de tamaño ",e.jsx(a,{children:n`m \times n`})," dada por",e.jsx(a,{block:!0,children:n`\begin{align*}
	\mathrm{D}\bvec{F} &= \begin{pmatrix}
			\nabla F_1 \\ \nabla F_2 \\ \vdots \\ \nabla F_m
	\end{pmatrix} \\
	\mathrm{D}\bvec{F} &= \begin{pmatrix}
		\dfrac{\partial F_1}{\partial x_1} & \dfrac{\partial F_1}{\partial x_2} & \cdots & \dfrac{\partial F_1}{\partial x_n} \\[1em]
		\dfrac{\partial F_2}{\partial x_1} & \dfrac{\partial F_2}{\partial x_2} & \cdots & \dfrac{\partial F_2}{\partial x_n} \\[1em]
		\vdots & \vdots & \ddots & \vdots \\[0.5em]
		\dfrac{\partial F_m}{\partial x_1} & \dfrac{\partial F_m}{\partial x_2} & \cdots & \dfrac{\partial F_m}{\partial x_n}
	\end{pmatrix} 
\end{align*}`}),"Evaluar la derivada de una función vectorial en un vector ",e.jsx(a,{children:n`\bvec{v}\in U`})," se denota por ",e.jsx(a,{children:n`\mathrm{D}\bvec{F}(\bvec{v})`})," y consiste en evaluar cada uno de los elementos de la matriz de derivadas en dicho vector."]}),e.jsx(s,{children:"Al construir la matriz de derivadas, téngase en cuenta que por cada fila se tiene el gradiente de una de las funciones escalares que componen la imagen de la función vectorial y a cada columna le corresponde una variable, no al contrario."}),e.jsx("h4",{children:"Diferenciabilidad de funciones vectoriales"}),e.jsxs("p",{children:["Sean ",e.jsx(a,{children:n`\bvec{F}\colon U\subseteq\mathbb{R}^{n} \to\mathbb{R}^{m}`})," una función vectorial de múltiples variables y ",e.jsx(a,{children:n`\bvec{v} \in U`}),", se dice que ",e.jsx(a,{children:n`\bvec{F}`})," es diferenciable en ",e.jsx(a,{children:n`\bvec{v}`})," si y solamente si"]}),e.jsxs("p",{children:["Si ",e.jsx(a,{children:n`\bvec{F},\bvec{G}\colon \mathbb{R}^{n}\to \mathbb{R}^{m}`})," son diferenciables en ",e.jsx(a,{children:n`\bvec{v}\in\mathbb{R}^{n}`})," y ",e.jsx(a,{children:n`\bvec{H}\colon\mathbb{R}^{m}\to\mathbb{R}^{k}`})," es diferenciable en ",e.jsx(a,{children:n`\bvec{F}(\bvec{v})`}),", entonces se satisfacen las siguientes propiedades"]}),e.jsxs("p",{children:["Para probar que una función vectorial es diferenciable en un punto. ","Si cada una de las derivadas parciales en la matriz de derivadas evaluada en ",e.jsx(a,{children:n`\bvec{v}`})," es continua, entonces la función es continua en ",e.jsx(a,{children:n`\bvec{v}`})," y por ende diferenciable en ",e.jsx(a,{children:n`\bvec{v}`}),"."]}),e.jsx("h3",{children:"Campos gradientes"}),e.jsxs(i,{concept:"Campo gradiente",children:["Sea ",e.jsx(a,{children:n`f\colon \mathbb{R}^{n}\to\mathbb{R}`})," una función escalar de múltiples variables. Un ",e.jsx("em",{children:"campo gradiente"})," o ",e.jsx("em",{children:"campo conservativo"})," es un campo vectorial ",e.jsx(a,{children:n`\bvec{F}`})," que tiene la forma",e.jsx(a,{children:n`\bvec{F} = \nabla (f) = \left(\parder{f}{x_1},\parder{f}{x_2},\ldots,\parder{f}{x_n} \right)`})]}),e.jsxs("p",{children:["Los campos gradientes se denominan alternativamente campos conservativos porque en física, el trabajo en un campo conservativo es cerrado. En ese contexto, la función escalar ",e.jsx(a,{children:n`f\colon \mathbb{R}^{n}\to\mathbb{R}`})," es el ",e.jsx("em",{children:"potencial"})," y el campo gradiente es el ",e.jsx("em",{children:"campo de fuerza"}),"."]}),e.jsx("h3",{children:"La divergencia"}),e.jsxs(i,{concept:"Divergencia",children:["Sea ",e.jsx(a,{children:n`\bvec{F}\colon \mathbb{R}^{m}\to \mathbb{R}^{n}`})," un campo vectorial de clase ",e.jsx(a,{children:n`C^1`}),", de forma que ",e.jsx(a,{children:n`\bvec{F}= (F_1,F_2,\ldots,F_n)`}),". La ",e.jsx("em",{children:"divergencia"})," de ",e.jsx(a,{children:n`\bvec{F}`}),", denotada por ",e.jsx(a,{children:n`\div\bvec{F}`}),", es una función escalar dada por el siguiente producto punto:",e.jsx(a,{block:!0,children:n`\begin{align*}
		\div\bvec{F} &= \nabla \cdot \bvec{F} \\
		\div\bvec{F} &= \left(\dparder{}{x_1}, \dparder{}{x_2},\ldots,\dparder{}{x_n}\right) \cdot (F_1,F_2,\ldots,F_n)\\
		\div\bvec{F} &= \sum_{i=1}^{n}\parder{F_i}{x_i}.
	\end{align*}`})]}),e.jsxs(c,{children:["El producto punto entre vectores es conmutativo, sin embargo la divergencia no es conmutativa, pues el operador vectorial nabla no conmuta. En general,",e.jsx(a,{block:!0,children:n`\div\bvec{F}=\nabla \cdot \bvec{F} \neq \bvec{F}\cdot \nabla.`})]}),e.jsxs("p",{children:["Para un campo vectorial ",e.jsx(a,{children:n`\bvec{G}\colon \mathbb{R}^{3}\to \mathbb{R}^{3}`})," de clase ",e.jsx(a,{children:n`C^1`}),", ",e.jsx(a,{children:n`\bvec{G}= (G_1,G_2,G_3)`}),", se tiene que",e.jsx(a,{block:!0,children:n`\begin{align*}
		\div\bvec{G} &= \nabla \cdot \bvec{G} \\
		\div\bvec{G} &= \left(\dparder{}{x}, \dparder{}{y},  \dparder{}{z}\right) \cdot (G_1,G_2,G_3)\\
		\div\bvec{G} &= \parder{G_1}{x_1}+ \parder{G_2}{x_2} + \parder{G_3}{x_3}.
	\end{align*}`})]}),e.jsxs("p",{children:["Sean ",e.jsx(a,{children:n`U_1,U_2 \subseteq \mathbb{R}^{m}`})," un conjunto abierto, ",e.jsx(a,{children:n`\bvec{F},\bvec{G}\colon U_1\to \mathbb{R}^{n}`})," campos vectoriales de clase ",e.jsx(a,{children:n`C^1`})," y ",e.jsx(a,{children:n`f,g\colon U_2 \to \mathbb{R}^{n}`})," funciones escalares, es posible demostrar las siguientes propiedades de la divergencia:"]}),e.jsxs("p",{children:["Por la propiedad v, la divergencia del rotacional de un campo vectorial es siempre nula. Por ende, se puede usar la divergencia de un campo vectorial para saber si dicho campo podría ser el resultado de una operación de rotacional. Sea ",e.jsx(a,{children:n`\bvec{F}`})," un campo vectorial,",e.jsx(a,{block:!0,children:n`\div \bvec{F} = 0 \ \iff \ \bvec{F} = \rot \bvec{G}`}),"para algún campo vectorial ",e.jsx(a,{children:n`\bvec{G}`}),"."]}),e.jsx("h3",{children:"El rotacional"}),e.jsxs(i,{concept:"Rotacional",children:["Sea ",e.jsx(a,{children:n`\bvec{F}\colon \mathbb{R}^{3}\to \mathbb{R}^{3}`})," un campo vectorial de clase ",e.jsx(a,{children:n`C^1`})," de forma que ",e.jsx(a,{children:n`\bvec{F}= (F_x,F_y,F_z)`}),". La ",e.jsx("em",{children:"rotacional"})," de ",e.jsx(a,{children:n`\bvec{F}`}),", denotada por ",e.jsx(a,{children:n`\rot\bvec{F}`}),", es un campo vectorial dado por el producto cruz a continuación:",e.jsx(a,{block:!0,children:n`\begin{align*}
		\mathrm{rot}\bvec{F} &= \nabla \times \bvec{F} \\
		\rot\bvec{F} &= \left(\dparder{}{x}, \dparder{}{y},  \dparder{}{z}\right) \times (F_x,F_y,F_z) \\
		\rot\bvec{F} &= \begin{vmatrix}
					\uveci & \uvecj & \uvec{k} \\[0.5	ex] \dparder{}{x} & \dparder{}{y} & \dparder{}{z} \\[1.7ex] F_x & F_y & F_z
				\end{vmatrix} \\
		\rot\bvec{F} &= \left(\dparder{F_z}{y}-\dparder{F_y}{z}\right) \uveci + \left( \dparder{F_z}{x} - \dparder{F_x}{z}\right) \uvecj +\left(\dparder{F_y}{x} - \dparder{F_x}{y} \right) \uvec{k}
	\end{align*}`})]}),e.jsxs("p",{children:["Sean ",e.jsx(a,{children:n`U_1,U_2 \subseteq \mathbb{R}^{m}`})," un conjunto abierto, ",e.jsx(a,{children:n`\bvec{F},\bvec{G}\colon U_1\to \mathbb{R}^{n}`})," campos vectoriales de clase ",e.jsx(a,{children:n`C^1`})," y ",e.jsx(a,{children:n`f,g\colon U_2 \to \mathbb{R}^{n}`})," funciones escalares, se pueden probar las propiedades del rotacional que se enuncian a continuación::"]}),e.jsxs("p",{children:["Por la propiedad iv, el rotacional de un campo vectorial es cero si y solamente si el campo vectorial es un campo gradiente. A causa de eso, el rotacional sirve para detectar si un campo vectorial puede ser el gradiente de una función escalar. Los campos gradientes no causan rotaciones. Sea ",e.jsx(a,{children:n`\bvec{F}`})," un campo vectorial,",e.jsx(a,{block:!0,children:n`\rot \bvec{F} = 0 \ \iff \ \bvec{F} = \nabla f`}),"para alguna función escalar ",e.jsx(a,{children:n`f`}),"."]})]}),e.jsxs(l,{title:"Integración",children:[e.jsx("h3",{children:"Integrales dobles"}),e.jsxs("p",{children:["Una ",e.jsx("em",{children:"integral doble"})," es la manera de integrar funciones de dos variables. La integral doble se interpreta geométricamente como el volumen debajo de la superficie."]}),e.jsxs("p",{children:["Se realizan integrales dobles en funciones cuyo dominio está restringido por una región rectangular ",e.jsx(a,{children:n`R`}),", dada por",e.jsx(a,{block:!0,children:n`R = [a,b]\times[b,c]`}),"donde ",e.jsx(a,{children:n`R`})," es un rectángulo en el plano ",e.jsx(a,{children:n`x,y`}),", el intervalo ",e.jsx(a,{children:n`[a,b]`})," contiene todos los puntos en ",e.jsx(a,{children:n`x`})," tales que ",e.jsx(a,{children:n`a\leq x\leq b`})," y el intervalo ",e.jsx(a,{children:n`[c,d]`})," contiene todos los puntos en ",e.jsx(a,{children:n`y`})," tales que ",e.jsx(a,{children:n`c\leq y\leq d`}),"."]}),e.jsxs("p",{children:["Se define entonces, para ",e.jsx(a,{children:n`n \in \mathbb{N} \setminus \{0\}`}),", el tamaño de cada subintervalo como",e.jsx(a,{block:!0,children:n`\begin{align*}
	&\Delta x = \frac{b-a}{n} && \Delta y = \frac{d-c}{n}
\end{align*}`}),"De forma que ",e.jsx(a,{children:n`x_0=a`}),", ",e.jsx(a,{children:n`x_i = a+i\Delta x`}),", ",e.jsx(a,{children:n`x_n = a+n\Delta x=b`}),". Se puede definir entonces una diferencia de área como",e.jsx(a,{block:!0,children:n`\Delta A = \delta x \Delta y`})]}),e.jsxs("p",{children:["De esa forma, la enésima suma de Riemann está dada por",e.jsx(a,{block:!0,children:n`\sum_{i=1}^{n}\sum_{j=1}^{n} f(C_{ij}) \Delta A.`})]}),e.jsxs("p",{children:["La función ",e.jsx(a,{children:n`f(x,y)`})," es integrable si",e.jsx(a,{block:!0,children:n`\lim_{n\to \infty} \sum_{i=1}^{n}\sum_{j=1}^{n} f(C_{ij}) \Delta A.`}),"existe y no depende de la escogencia de los puntos ",e.jsx(a,{children:n`c_{ij}`}),"."]}),e.jsxs("p",{children:["la integral doble de la función ",e.jsx(a,{children:n`f(x,y)`})," se denota por",e.jsx(a,{block:!0,children:n`\int_{c}^{d} \int_{a}^{b}  f(x,y) \, \mathrm{d}x \, \mathrm{d}y.`})]}),e.jsx("h3",{children:"Integrales triples"})]})]});export{k as default};
